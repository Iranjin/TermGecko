#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('main.py', b'\nfrom time import sleep\n\nfrom codes import *\nfrom config import *\nfrom filesys import *\nfrom language import *\nfrom misc import *\nfrom tcp import *\nfrom terminal import *\n\n\ndef main_init():\n    global BASE_CONFIG, cfg, tab, term, tcp\n\n    BASE_CONFIG = {\n        "general": {\n            "language": EN,\n            "sleep": 1\n        },\n        "tcpgecko": {\n            "ip_address": None,\n            "timeout": 3,\n            "auto_connect": True\n        },\n        "directory": {\n            "code_file": None\n        }\n    }\n\n    cfg = Config("settings.ini", BASE_CONFIG)\n    tab = Tab()\n    tcp = TCPGecko()\n    term = Terminal()\n\n    if cfg.get("tcpgecko", "ip_address", auto_type = True):\n        tab.Connect()\n    \n\ndef main():\n    main_init()\n\n    language = cfg.get("general", "language")\n\n    tabs = {\n        Language[language]["tab"]["send"]: tab.SendCode,\n        Language[language]["tab"]["disable"]: tab.DisableCode,\n        Language[language]["tab"]["connect"]: tab.Connect,\n        Language[language]["tab"]["code_manager"]: tab.CodeList,\n    }\n\n    # with File(".titles") as title:\n    #     if not title.exists():\n    #         titles = getFile("https://raw.githubusercontent.com/Iranjin/TermGecko/main/titles", str)\n    #         title.create().overWrite(titles)\n    \n    while True:\n        tcp_status = "%s -> %s" % (\n            Language[language]["tcp_status"],\n            ("%s [%s]" % (Language[language]["main_connected"], tcp.ip_address) if tcp.isConnected() else Language[language]["main_no_connection"]))\n        \n        element = term.elementSelecter(\n            tabs.keys(), "%s\\n\\nTermGecko" % (tcp_status))\n        \n        tabs[element]()\n\n\n\nclass Tab:\n\n    def __init__(self):\n        self.sleep = cfg.get("general", "sleep", float)\n        self.language = cfg.get("general", "language")\n        self.file = None\n        self.connect_count = 0\n\n    \n    def SendCode(self):...\n\n    \n    def DisableCode(self):...\n\n    \n    def Connect(self):\n        def connect(ip_address: str):\n            term.cls()\n            print(Language[self.language]["connecting"])\n            \n            try:\n                tcp.socketInit()\n                tcp.connect(ip_address)\n                \n                cfg.write("tcpgecko", "ip_address", ip_address)\n\n                term.cls()\n\n                print("%s [%s]" % (Language[self.language]["connected"], ip_address))\n                \n                sleep(cfg.get("general", "sleep", float))\n\n                term.cls()\n            except:\n                term.cls()\n                tcp.socketInit()\n                return -1\n            else:\n                return 0\n\n\n        if tcp.isConnected():\n            tcp.disconnect()\n            tcp.socketInit()\n            return\n\n        while True:\n            tcp.setTimeout(cfg.get("tcpgecko", "timeout", float))\n            ip_address = cfg.get("tcpgecko", "ip_address", auto_type = True)\n\n            if not self.connect_count and isIpAddress(ip_address):\n                self.connect_count += 1\n\n                if not cfg.get("tcpgecko", "auto_connect", auto_type = True) and self.connect_count == 1:\n                    return\n\n                if connect(ip_address) == 0:\n                    return\n                \n            term.cls()\n\n            print(Language[self.language]["pls_enter_ip"])\n\n            ip_address = input("%s \\\\ 192.168." % (Language[self.language]["ip_address"]))\n\n            if not ip_address:\n                return\n\n            ip_address = "192.168.%s" % (ip_address)\n\n            term.cls()\n\n            if not isIpAddress(ip_address):\n                continue\n            \n            if connect(ip_address) == 0:\n                return\n    \n\n    def SelectCodeFile(self):\n        term.cls()\n\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n\n        files = []\n\n        for file in os.listdir(current_dir):\n            file = File(file)\n\n            if file.isFile() and file.extention in ["xml", "txt"]:\n                files.append(file.path)\n        \n        element = term.elementSelecter(files, "SelectCodeFile", self.file)\n\n        if not element:\n            return\n\n        self.file = element\n        cfg.write("directory", "code_file", self.file)\n\n    \n    def CodeList(self):\n        term.cls()\n\n        code_file_path = cfg.get("directory", "code_file", auto_type = True)\n\n        if not code_file_path and not self.file:\n            self.SelectCodeFile()\n        else:\n            self.file = code_file_path\n\n        while True:\n                    \n\n            # code_file = File()\n\n\n\n            element_list = ""\n\n            # for element in \n\n            # print("")\n\n            try:\n                input_cmd = input("CodeList \\\\ ")\n                input_cmd_s = input_cmd.split()\n\n                if not input_cmd:\n                    break\n\n                if " " not in input_cmd and isNum(input_cmd):\n                    index = int(input_cmd) - 1\n                \n                elif input_cmd == "c":\n                    self.SelectCodeFile()\n                \n                elif input_cmd in ["c", "change"]:\n                    self.SelectCodeFile()\n                \n                # elif \n\n\n                term.cls()\n            except ValueError:\n                continue\n            except IndexError:\n                continue\n\ntry:\n    main()\nexcept Exception as e:\n    language = Config("settings.ini", BASE_CONFIG).get("general", "language")\n    term = Terminal()\n\n    term.cls()\n    print("Error: \'%s\'\\n%s" % (type(e), Language[language]["error_screenshot"]))\n    sleep(5)\n    term.cls()\n\n    raise e\n')
    __stickytape_write_module('codes.py', b'\nfrom misc import *\nfrom filesys import *\nfrom cstr import *\n\n\nclass CL:\n    \n    def __init__(self, path: str, code_list_space: int = 1, format: bool = None):\n        self.__file = File(path)\n        self.__code_list_space = code_list_space\n        self.__format = format\n    \n\n    def getFile(self):\n        return File(self.__file)\n    \n\n    def parse(self):\n        result = []\n\n        for code in self.__file.read().split("\\n;\\n"):\n            entry = []\n\n            lines = code.strip().splitlines()\n\n            entry.append(lines.pop(0))\n\n            line = lines.pop(0)\n            if line.startswith("@"):\n                entry.append(line\n                               .lstrip("@")\n                               .replace("\\\\n", "\\n"))\n                line = lines.pop(0)\n            else:\n                entry.append(None)\n\n            entry.append((True if line.lower() == "on" else False))\n            entry.append("\\n".join(lines))\n\n            result.append(entry)\n        \n        return result\n    \n\n    def write(self, code_list: list):\n        result = ""\n\n        space = "\\n" * self.__code_list_space\n\n        for i, entry in enumerate(code_list):\n            name, comment, enabled, code = entry\n\n            result += name + "\\n"\n\n            if comment:\n                result += "@" + comment.replace("\\n", "\\\\n") + "\\n"\n\n            result += ("on" if enabled else "off") + "\\n"\n\n            if self.__format is None:\n                result += code + "\\n"\n            elif self.__format:\n                result += cstr(code).formatCode() + "\\n"\n            else:\n                result += cstr(code).stripWhitespace() + "\\n"\n\n            if i != len(code_list) - 1:\n                result += "%s;%s\\n" % (space, space)\n\n        self.__file.overWrite(result.strip())\n\n\n    def toXML(self):\n        result = \'<?xml version="1.0" encoding="UTF-16"?><codes>\\n\'\n\n        for entry in self.parse():\n            name, comment, enabled, code = entry\n\n            result += \'    <entry name="%s">\\n\' % (name)\n            result += \'        <code>%s</code>\\n\' % (code)\n            result += \'        <authors/>\\n\'\n            result += \'        <raw_assembly>false</raw_assembly>\\n\'\n            result += \'        <assembly_ram_write>%s</assembly_ram_write>\\n\' % (("true" if cstr(code).isCafeCode() else "false"))\n            result += "        " + (\'<comment>%s</comment>\' % (comment) if comment else "<comment/>") + "\\n"\n            result += \'        <enabled>%s</enabled>\\n\' % (("true" if enabled else "false"))\n            result += \'    </entry>\\n\'\n\n        result += "</codes>"\n        \n        return result\n\n\n\nclass XML:\n    \n    def __init__(self, path: str):\n        self.__file = File(path)\n\n\n    def getFile(self):\n        return File(self.__file)\n\n    \n    def parse(self):\n        result = []\n\n        for entry in self.__parse():\n            _entry = []\n\n            _entry.append(entry["name"])\n            if entry["comment"]:\n                _entry.append(entry["comment"])\n            else:\n                _entry.append(None)\n            _entry.append(entry["enabled"])\n            _entry.append(cstr(entry["code"]).formatCode())\n\n            result.append(_entry)\n        \n        return result\n\n    \n    def __parse(self):\n        result = []\n\n        xml_string = self.__file.read()\n        \n        while len(xml_string) > 0:\n            entry_start = xml_string.find("<entry")\n            if entry_start == -1:\n                break\n            entry_end = xml_string.find("</entry>") + len("</entry>")\n            entry_xml = xml_string[entry_start:entry_end]\n            xml_string = xml_string[entry_end:]\n\n            entry = self.__parse_entry(entry_xml)\n            result.append(entry)\n\n        return result\n    \n\n    def __parse_entry(self, entry_xml: str):\n        result = {}\n\n        name_start = entry_xml.find("name=\\"") + len("name=\\"")\n        name_end = entry_xml.find("\\"", name_start)\n        result["name"] = entry_xml[name_start:name_end]\n\n        code_start = entry_xml.find("<code>") + len("<code>")\n        code_end = entry_xml.find("</code>")\n        result["code"] = entry_xml[code_start:code_end].strip()\n\n        comment_start = entry_xml.find("<comment>")\n        comment_end = entry_xml.find("</comment>")\n        if comment_start != -1 and comment_end != -1:\n            comment_start += len("<comment>")\n            result["comment"] = entry_xml[comment_start:comment_end].strip()\n        else:\n            result["comment"] = None\n\n        enabled_start = entry_xml.find("<enabled>") + len("<enabled>")\n        enabled_end = entry_xml.find("</enabled>")\n        enable = entry_xml[enabled_start:enabled_end].strip()\n        result["enabled"] = (True if enable == "true" else False)\n\n        return result\n\n\n    def toCL(self, space: int = 1):\n        result = ""\n\n        _space = "\\n" * space\n        xml = self.__parse()\n\n        for i, entry in enumerate(xml):\n            result += entry["name"] + "\\n"\n            result += ("on" if entry["enabled"] else "off") + "\\n"\n            if entry["comment"]:\n                result += "@" + entry["comment"].replace("\\n", "\\\\n") + "\\n"\n            result += entry["code"] + "\\n"\n\n            if i != len(xml) - 1:\n                result += "%s;%s\\n" % (_space, _space)\n        \n        return result.strip()\n')
    __stickytape_write_module('misc.py', b'\nimport re\nimport urllib.request\nimport ssl\nfrom typing import TypeVar\n\n\nT = TypeVar("T")\n\n\ndef getFile(url: str, obj: type[T] = bytes):\n    ssl._create_default_https_context = ssl._create_unverified_context\n    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"}\n    req = urllib.request.Request(url, headers = headers)\n    response = urllib.request.urlopen(req).read()\n\n    if obj == bytes:\n        return response\n    else:\n        return obj(response.decode("utf-8"))\n\n\ndef isNum(arg: T):\n    try:\n        int(arg)\n    except ValueError:\n        return False\n    else:\n        return True\n\n\ndef digit(num: int):\n    return len(str(num))\n\n\ndef isIpAddress(ip_address: str):\n    try:\n        return re.match(r\'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$\', ip_address) is not None\n    except TypeError:\n        return False\n\n\ndef split(string: str, index: int):\n    result = string.split()\n\n    if index in range(len(result)):\n        return result[index]\n')
    __stickytape_write_module('filesys.py', b'\nimport os\nimport shutil\n\nclass File:\n\n    def __init__(self, path: str):\n        self.__path = path\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\n    def __str__(self):\n        return self.read()\n        \n    \n    @property\n    def extention(self):\n        _, extension = os.path.splitext(self.name)\n        return extension.lstrip(".")\n        \n    \n    @property\n    def name(self):\n        return os.path.basename(self.__path)\n    \n\n    @property\n    def dir(self):\n        return os.path.dirname(self.__path)\n\n\n    @property\n    def path(self):\n        return self.__path\n    \n\n    @property\n    def size(self):\n        return os.path.getsize(self.__path)\n\n\n    def __read_bin(self):\n        with open(self.__path, "rb") as bin:\n            return bin.read()\n    \n\n    def __enc(self, _encoding: str):\n        return (_encoding if _encoding else self.encoding())\n    \n\n    def encoding(self):\n        encodings = [\n            \'utf-8\',\n            \'utf-16\',\n            \'utf-32\',\n            \'ascii\',\n            \'latin-1\',\n            \'cp932\',\n            \'shift-jis\',\n            \'euc-jp\',\n            \'gbk\',\n            \'big5\',\n            \'utf-8-sig\',\n            \'utf-16-le\',\n            \'utf-16-be\',\n            \'utf-32-le\',\n            \'utf-32-be\',\n            \'iso-8859-1\',\n            \'iso-8859-2\',\n            \'iso-8859-3\',\n            \'iso-8859-4\',\n            \'iso-8859-5\',\n            \'iso-8859-6\',\n            \'iso-8859-7\',\n            \'iso-8859-8\',\n            \'iso-8859-9\',\n            \'iso-8859-10\',\n            \'iso-8859-13\',\n            \'iso-8859-14\',\n            \'iso-8859-15\',\n            \'iso-8859-16\',\n            \'macintosh\',\n            \'mac-roman\',\n            \'mac-turkish\',\n            \'mac-cyrillic\',\n            \'mac-greek\',\n            \'mac-iceland\',\n            \'mac-romanian\',\n            \'mac-croatian\',\n            \'mac-ukrainian\',\n            \'cp437\',\n            \'cp850\',\n            \'cp852\',\n            \'cp855\',\n            \'cp857\',\n            \'cp858\',\n            \'cp860\',\n            \'cp861\',\n            \'cp862\',\n            \'cp863\',\n            \'cp865\',\n            \'cp866\',\n            \'cp869\',\n            \'cp874\',\n            \'cp1250\',\n            \'cp1251\',\n            \'cp1252\',\n            \'cp1253\',\n            \'cp1254\',\n            \'cp1255\',\n            \'cp1256\',\n            \'cp1257\',\n            \'cp1258\',\n            \'cp65001\',\n            \'koi8-r\',\n            \'koi8-u\',\n            \'kz1048\',\n            \'hz\',\n            \'ptcp154\',\n            \'punycode\',\n            \'idna\',\n            \'base64\',\n            \'quopri\',\n            \'uu\',\n            \'bz2\',\n            \'zlib\',\n            \'rot_13\',\n            \'raw_unicode_escape\',\n            \'unicode_escape\',\n            \'unicode_internal\'\n        ]\n\n        bytes_text = self.__read_bin()\n\n        for encoding in encodings:\n            try:\n                bytes_text.decode(encoding)\n            except UnicodeDecodeError:\n                continue\n            else:\n                return encoding\n\n        return None\n    \n\n    def setPath(self, path: str):\n        self.__path = path\n\n        return self\n\n\n    def create(self):\n        if os.path.exists(self.__path):\n            return self\n        \n        with open(self.__path, "a", encoding = "utf-8") as f:\n            f.write("")\n\n        return self\n\n\n    def getDir(self):\n        return Dir(self.dir)\n\n\n    def write(self, string: str, _encoding: str = None):\n        self.__write(self.__path, "a", string, self.__enc(_encoding))\n        \n        return self\n    \n\n    def writeBin(self, binary: bytes):\n        self.__write_bin(self.__path, "ab", binary)\n        \n        return self\n\n\n    def overWrite(self, string: str, _encoding: str = None):\n        self.__write(self.__path, "w", string, self.__enc(_encoding))\n        \n        return self\n    \n\n    def overWriteBin(self, binary: bytes):\n        self.__write_bin(self.__path, "wb", binary)\n        \n        return self\n\n\n    def __write(self, path: str, mode: str, string: str, _encoding: str = None):\n        with open(path, mode, encoding = _encoding) as f:\n            f.write(string)\n\n\n    def __write_bin(self, path: str, mode: str, binary: bytes):\n        with open(path, mode) as f:\n            f.write(binary)\n\n\n    def read(self, _encoding: str = None):\n        return self.__read(self.__path, self.__enc(_encoding))\n\n\n    def readBin(self):\n        return self.__read_bin()\n\n\n    def __read(self, path: str, _encoding: str = None):\n        with open(path, "r" , encoding = _encoding) as f:\n            return f.read()\n    \n\n    def rename(self, file_name: str):\n        directory = os.path.dirname(self.__path)\n        dst = os.path.join(directory, file_name)\n\n        os.rename(self.__path, dst)\n        self.__path = dst\n\n        return self\n\n\n    def delete(self):\n        os.remove(self.__path)\n\n        return self\n\n    \n    def move(self, path: str):\n        _path = os.path.join(path, self.name)\n\n        if not os.path.exists(path):\n            os.makedirs(path)\n\n        with open(path, "wb") as bin:\n            bin.write(self.__read_bin())\n        \n        self.delete()\n\n        self.__path = _path\n\n        return self\n\n    \n    def exists(self):\n        return os.path.exists(self.__path)\n    \n\n    def isFile(self):\n        return os.path.isfile(self.__path)\n    \n\n    def isDir(self):\n        return os.path.isdir(self.__path)\n\n    \n    def duplicate(self, _path: str, name: str = None):\n        path = os.path.join(_path, (name if name else self.name))\n\n        if _path and not os.path.exists(_path):\n            os.makedirs(_path)\n\n        with open(path, "wb") as bin:\n            bin.write(self.__read_bin())\n\n        self.__path = path\n\n        return self\n\n\n\n\nclass Dir:\n\n    def __init__(self, path: str):\n        self.__path = path\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n        \n    \n    @property\n    def name(self):\n        return os.path.basename(self.__path)\n    \n\n    @property\n    def dir(self):\n        return os.path.dirname(self.__path)\n\n\n    @property\n    def path(self):\n        return self.__path\n    \n\n    @property\n    def size(self):\n        return os.path.getsize(self.__path)\n    \n\n    def setPath(self, path: str):\n        self.__path = path\n\n        return self\n\n\n    def create(self):\n        os.makedirs(self.__path, exist_ok = True)\n\n        return self\n\n\n    def delete(self):\n        shutil.rmtree(self.__path)\n\n        return self\n\n    \n    def move(self, path: str):\n        shutil.move(self.__path, path)\n\n        return self\n    \n    \n    def exists(self):\n        return os.path.exists(self.__path)\n    \n\n    def isFile(self):\n        return os.path.isfile(self.__path)\n    \n\n    def isDir(self):\n        return os.path.isdir(self.__path)\n    \n    \n    def dirStats(self):\n        file_cnt = 0\n        dir_cnt = 0\n\n        for _, dir, file in os.walk(self.__path):\n            dir_cnt += len(dir)\n            file_cnt += len(file)\n\n        return file_cnt, dir_cnt\n    \n    \n    def rename(self, file_name: str):\n        directory = os.path.dirname(self.__path)\n        dst = os.path.join(directory, file_name)\n\n        os.rename(self.__path, dst)\n\n        self.__path = dst\n\n        return self\n    \n    \n    def __getDir(self, directory):\n        contents = {}\n        \n        for name in os.listdir(directory):\n            path = os.path.join(directory, name)\n            if os.path.isdir(path):\n                contents[name] = self.__getDir(path)\n            else:\n                contents[name] = File(path).readBin()\n        \n        return contents\n    \n\n    def getDirState(self):\n        if not os.path.isdir(self.__path):\n            raise NotADirectoryError("\'%s\' is not a directory." % (self.__path))\n        \n        return self.__getDir(self.__path)\n    \n\n    def __restoreDirState(self, directory: str, state: dict):\n        for name, data in state.items():\n            path = os.path.join(directory, name)\n\n            if isinstance(data, dict):\n                os.makedirs(path, exist_ok = True)\n                self.__restoreDirState(path, data)\n            else:\n                File(path).overWriteBin(data)\n\n\n    def restoreDirState(self, state: dict):\n        if not self.exists():\n            self.create()\n\n        self.__restoreDirState(self.__path, state)\n\n        return self\n')
    __stickytape_write_module('cstr.py', b'\nclass cstr(str):\n    \n    def stripWhitespace(self) -> \'cstr\':\n        return cstr(self\n                    .replace(" ", "")\n                    .replace("\\n", "")\n                )\n    \n\n    def isCode(self):\n        code = self.stripWhitespace()\n\n        if (len(code) - code.count("#")) % 8:\n            return False\n\n        for x in code:\n            if x.lower() not in [\n                \'a\', \'b\', \'c\', \'d\', \'e\', \'f\',\n                \'0\', \'1\', \'2\', \'3\', \'4\', \'5\',\n                \'6\', \'7\', \'8\', \'9\', \'#\'\n                ]:\n                return False\n        return True\n    \n\n    def isCafeCode(self):\n        code = self.formatCode()\n        \n        for line in code.splitlines():\n            if line.startswith("00020000"): return True\n            elif line.startswith("00120000"): return True\n            elif line.startswith("30000000"): return True\n            elif line.startswith("31000000"): return True\n            elif line.startswith("C0") and line.endswith("60000000"): return True\n            elif line.startswith("30100000") and line.endswith("00000000"): return True\n            elif line.startswith("10000000") and line.endswith("50000000"): return True\n            elif line.startswith("D0000000") and line.endswith("DEADCAFE"): return True\n            \n        return False\n        \n\n    def line(self):\n        if not self:\n            return 0\n        return self.count("\\n") + 1\n\n\n    def isFormatted(self):\n        for line in self.splitlines():\n            line = line.lstrip("#")\n\n            if len(line) != 17 or line[8] != " ":\n                return False\n        return True\n    \n\n    def sortLine(self) -> \'cstr\':\n        return cstr("\\n".join(self.splitlines()))\n\n\n    def formatCode(self) -> \'cstr\':\n        code = self.stripWhitespace()\n\n        result = ""\n        \n        i, c = 0, 0\n        while i * 16 + c < len(code):\n            p1 = code[i * 16 + c : i * 16 + 16 + c]\n\n            if p1.startswith("#"):\n                c += 1\n                p2 = code[i * 16 + c : i * 17 + 17]\n                line = p2[:9] + " " + p2[9:]\n            else:\n                line = p1[:8] + " " + p1[8:]\n\n            result += line[:18] + "\\n"\n\n            i += 1\n\n        return cstr(result.rstrip("\\n"))\n\n\n    def getEnableLine(self) -> \'cstr\':\n        result = ""\n\n        for line in self.formatCode().splitlines():\n            if not line.startswith("#"):\n                result += line + "\\n"\n\n        if not self.isFormatted():\n            return cstr(result).stripWhitespace()\n\n        return cstr(result.rstrip("\\n"))\n    \n\n    def getDisableLine(self) -> \'cstr\':\n        result = ""\n\n        for line in self.formatCode().splitlines():\n            if line.startswith("#"):\n                result += line.lstrip("#") + "\\n"\n\n        if not self.isFormatted():\n            return cstr(result).stripWhitespace()\n\n        return cstr(result.rstrip("\\n"))\n    \n\n    def splitRamWrite(self):\n        result = []\n\n        for line in self.formatCode().splitlines():\n            result.append([int(x, 16) for x in line.lstrip("#").split()])\n        \n        return result\n    \n\n    def splitCafeCode(self):\n        result = []\n\n        for line in self.getEnableLine().formatCode().split():\n            result.append(int(line.lstrip("#"), 16))\n        \n        return result\n')
    __stickytape_write_module('config.py', b'\nimport configparser_file as configparser\n\nfrom misc import *\nfrom filesys import *\n\nclass Config:\n    \n    def __init__(\n            self,\n            config_path: str,\n            default: dict = None\n        ):\n        self.__cfgp = configparser.ConfigParser()\n        self.__file = File(config_path)\n        self.__default = default\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\n    def __str__(self):\n        return self.getDict()\n\n    \n    def __read(self):\n        if not self.__file.exists():\n            self.__file.create()\n\n        self.__cfgp.read(\n            self.__file.path,\n            encoding = self.__file.encoding()\n        )\n\n        \n    def getFile(self):\n        return File(self.__file)\n\n    \n    def writeDict(self, dict_config: dict, over_write: bool = False):\n        self.__read()\n\n        if over_write:\n            self.__cfgp.clear()\n\n        for section, options in dict_config.items():\n            self.__cfgp[section] = options\n\n        with open(self.__file.path, "w", encoding = self.__file.encoding()) as file:\n            self.__cfgp.write(file)\n        \n        return self\n\n\n    def write(self, section: str, option: str, write_data: str):\n        data = self.getDict()\n\n        if section not in data:\n            data[section] = {}\n        \n        data[section][option] = write_data\n        \n        self.writeDict(data)\n\n        return self\n\n    \n    def getDict(self):\n        self.__read()\n        \n        data = {}\n        for section in self.__cfgp.sections():\n            data[section] = dict(self.__cfgp.items(section))\n        \n        return data\n    \n\n    def get(self, section: str, option: str, obj: type[T] = str, auto_type: bool = False):\n        origin = self.getDict()\n\n        if self.__default and (not self.hasSection(section) or not self.hasOption(section, option)):\n            write_data = origin\n\n            if section not in write_data:\n                write_data[section] = {}\n\n            write_data[section][option] = str(self.__default[section][option])\n            self.writeDict(write_data)\n\n        try:\n            result = origin[section][option]\n            if auto_type:\n                if result == "None":\n                    return None\n                elif result == "True":\n                    return True\n                elif result == "False":\n                    return False\n                elif isNum(result):\n                    return int(result)\n            return obj(result)\n        except KeyError:\n            return None\n    \n\n    def removeSection(self, section: str):\n        if self.hasSection(section):\n            self.__cfgp.remove_section(section)\n\n        return self\n    \n\n    def removeOption(self, option: str):\n        if self.hasOption(option):\n            self.__cfgp.remove_option(option)\n\n        return self\n\n\n    def hasSection(self, section: str):\n        return self.__cfgp.has_section(section)\n    \n    \n    def hasOption(self, section: str, option: str):\n        return self.__cfgp.has_option(section, option)\n')
    __stickytape_write_module('configparser_file.py', b'\nfrom collections.abc import MutableMapping\nfrom collections import ChainMap as _ChainMap\nimport functools\nimport io\nimport itertools\nimport os\nimport re\nimport sys\nimport warnings\n\n__all__ = ["NoSectionError", "DuplicateOptionError", "DuplicateSectionError",\n           "NoOptionError", "InterpolationError", "InterpolationDepthError",\n           "InterpolationMissingOptionError", "InterpolationSyntaxError",\n           "ParsingError", "MissingSectionHeaderError",\n           "ConfigParser", "SafeConfigParser", "RawConfigParser",\n           "Interpolation", "BasicInterpolation",  "ExtendedInterpolation",\n           "LegacyInterpolation", "SectionProxy", "ConverterMapping",\n           "DEFAULTSECT", "MAX_INTERPOLATION_DEPTH"]\n\n_default_dict = dict\nDEFAULTSECT = "DEFAULT"\n\nMAX_INTERPOLATION_DEPTH = 10\n\n\n\n# exception classes\nclass Error(Exception):\n    """Base class for ConfigParser exceptions."""\n\n    def __init__(self, msg=\'\'):\n        self.message = msg\n        Exception.__init__(self, msg)\n\n    def __repr__(self):\n        return self.message\n\n    __str__ = __repr__\n\n\nclass NoSectionError(Error):\n    """Raised when no section matches a requested option."""\n\n    def __init__(self, section):\n        Error.__init__(self, \'No section: %r\' % (section,))\n        self.section = section\n        self.args = (section, )\n\n\nclass DuplicateSectionError(Error):\n    """Raised when a section is repeated in an input source.\n\n    Possible repetitions that raise this exception are: multiple creation\n    using the API or in strict parsers when a section is found more than once\n    in a single input file, string or dictionary.\n    """\n\n    def __init__(self, section, source=None, lineno=None):\n        msg = [repr(section), " already exists"]\n        if source is not None:\n            message = ["While reading from ", repr(source)]\n            if lineno is not None:\n                message.append(" [line {0:2d}]".format(lineno))\n            message.append(": section ")\n            message.extend(msg)\n            msg = message\n        else:\n            msg.insert(0, "Section ")\n        Error.__init__(self, "".join(msg))\n        self.section = section\n        self.source = source\n        self.lineno = lineno\n        self.args = (section, source, lineno)\n\n\nclass DuplicateOptionError(Error):\n    """Raised by strict parsers when an option is repeated in an input source.\n\n    Current implementation raises this exception only when an option is found\n    more than once in a single file, string or dictionary.\n    """\n\n    def __init__(self, section, option, source=None, lineno=None):\n        msg = [repr(option), " in section ", repr(section),\n               " already exists"]\n        if source is not None:\n            message = ["While reading from ", repr(source)]\n            if lineno is not None:\n                message.append(" [line {0:2d}]".format(lineno))\n            message.append(": option ")\n            message.extend(msg)\n            msg = message\n        else:\n            msg.insert(0, "Option ")\n        Error.__init__(self, "".join(msg))\n        self.section = section\n        self.option = option\n        self.source = source\n        self.lineno = lineno\n        self.args = (section, option, source, lineno)\n\n\nclass NoOptionError(Error):\n    """A requested option was not found."""\n\n    def __init__(self, option, section):\n        Error.__init__(self, "No option %r in section: %r" %\n                       (option, section))\n        self.option = option\n        self.section = section\n        self.args = (option, section)\n\n\nclass InterpolationError(Error):\n    """Base class for interpolation-related exceptions."""\n\n    def __init__(self, option, section, msg):\n        Error.__init__(self, msg)\n        self.option = option\n        self.section = section\n        self.args = (option, section, msg)\n\n\nclass InterpolationMissingOptionError(InterpolationError):\n    """A string substitution required a setting which was not available."""\n\n    def __init__(self, option, section, rawval, reference):\n        msg = ("Bad value substitution: option {!r} in section {!r} contains "\n               "an interpolation key {!r} which is not a valid option name. "\n               "Raw value: {!r}".format(option, section, reference, rawval))\n        InterpolationError.__init__(self, option, section, msg)\n        self.reference = reference\n        self.args = (option, section, rawval, reference)\n\n\nclass InterpolationSyntaxError(InterpolationError):\n    """Raised when the source text contains invalid syntax.\n\n    Current implementation raises this exception when the source text into\n    which substitutions are made does not conform to the required syntax.\n    """\n\n\nclass InterpolationDepthError(InterpolationError):\n    """Raised when substitutions are nested too deeply."""\n\n    def __init__(self, option, section, rawval):\n        msg = ("Recursion limit exceeded in value substitution: option {!r} "\n               "in section {!r} contains an interpolation key which "\n               "cannot be substituted in {} steps. Raw value: {!r}"\n               "".format(option, section, MAX_INTERPOLATION_DEPTH,\n                         rawval))\n        InterpolationError.__init__(self, option, section, msg)\n        self.args = (option, section, rawval)\n\n\nclass ParsingError(Error):\n    """Raised when a configuration file does not follow legal syntax."""\n\n    def __init__(self, source=None, filename=None):\n        # Exactly one of `source\'/`filename\' arguments has to be given.\n        # `filename\' kept for compatibility.\n        if filename and source:\n            raise ValueError("Cannot specify both `filename\' and `source\'. "\n                             "Use `source\'.")\n        elif not filename and not source:\n            raise ValueError("Required argument `source\' not given.")\n        elif filename:\n            source = filename\n        Error.__init__(self, \'Source contains parsing errors: %r\' % source)\n        self.source = source\n        self.errors = []\n        self.args = (source, )\n\n    @property\n    def filename(self):\n        """Deprecated, use `source\'."""\n        warnings.warn(\n            "The \'filename\' attribute will be removed in Python 3.12. "\n            "Use \'source\' instead.",\n            DeprecationWarning, stacklevel=2\n        )\n        return self.source\n\n    @filename.setter\n    def filename(self, value):\n        """Deprecated, user `source\'."""\n        warnings.warn(\n            "The \'filename\' attribute will be removed in Python 3.12. "\n            "Use \'source\' instead.",\n            DeprecationWarning, stacklevel=2\n        )\n        self.source = value\n\n    def append(self, lineno, line):\n        self.errors.append((lineno, line))\n        self.message += \'\\n\\t[line %2d]: %s\' % (lineno, line)\n\n\nclass MissingSectionHeaderError(ParsingError):\n    """Raised when a key-value pair is found before any section header."""\n\n    def __init__(self, filename, lineno, line):\n        Error.__init__(\n            self,\n            \'File contains no section headers.\\nfile: %r, line: %d\\n%r\' %\n            (filename, lineno, line))\n        self.source = filename\n        self.lineno = lineno\n        self.line = line\n        self.args = (filename, lineno, line)\n\n\n# Used in parser getters to indicate the default behaviour when a specific\n# option is not found it to raise an exception. Created to enable `None\' as\n# a valid fallback value.\n_UNSET = object()\n\n\nclass Interpolation:\n    """Dummy interpolation that passes the value through with no changes."""\n\n    def before_get(self, parser, section, option, value, defaults):\n        return value\n\n    def before_set(self, parser, section, option, value):\n        return value\n\n    def before_read(self, parser, section, option, value):\n        return value\n\n    def before_write(self, parser, section, option, value):\n        return value\n\n\nclass BasicInterpolation(Interpolation):\n    """Interpolation as implemented in the classic ConfigParser.\n\n    The option values can contain format strings which refer to other values in\n    the same section, or values in the special default section.\n\n    For example:\n\n        something: %(dir)s/whatever\n\n    would resolve the "%(dir)s" to the value of dir.  All reference\n    expansions are done late, on demand. If a user needs to use a bare % in\n    a configuration file, she can escape it by writing %%. Other % usage\n    is considered a user error and raises `InterpolationSyntaxError\'."""\n\n    _KEYCRE = re.compile(r"%\\(([^)]+)\\)s")\n\n    def before_get(self, parser, section, option, value, defaults):\n        L = []\n        self._interpolate_some(parser, option, L, value, section, defaults, 1)\n        return \'\'.join(L)\n\n    def before_set(self, parser, section, option, value):\n        tmp_value = value.replace(\'%%\', \'\') # escaped percent signs\n        tmp_value = self._KEYCRE.sub(\'\', tmp_value) # valid syntax\n        if \'%\' in tmp_value:\n            raise ValueError("invalid interpolation syntax in %r at "\n                             "position %d" % (value, tmp_value.find(\'%\')))\n        return value\n\n    def _interpolate_some(self, parser, option, accum, rest, section, map,\n                          depth):\n        rawval = parser.get(section, option, raw=True, fallback=rest)\n        if depth > MAX_INTERPOLATION_DEPTH:\n            raise InterpolationDepthError(option, section, rawval)\n        while rest:\n            p = rest.find("%")\n            if p < 0:\n                accum.append(rest)\n                return\n            if p > 0:\n                accum.append(rest[:p])\n                rest = rest[p:]\n            # p is no longer used\n            c = rest[1:2]\n            if c == "%":\n                accum.append("%")\n                rest = rest[2:]\n            elif c == "(":\n                m = self._KEYCRE.match(rest)\n                if m is None:\n                    raise InterpolationSyntaxError(option, section,\n                        "bad interpolation variable reference %r" % rest)\n                var = parser.optionxform(m.group(1))\n                rest = rest[m.end():]\n                try:\n                    v = map[var]\n                except KeyError:\n                    raise InterpolationMissingOptionError(\n                        option, section, rawval, var) from None\n                if "%" in v:\n                    self._interpolate_some(parser, option, accum, v,\n                                           section, map, depth + 1)\n                else:\n                    accum.append(v)\n            else:\n                raise InterpolationSyntaxError(\n                    option, section,\n                    "\'%%\' must be followed by \'%%\' or \'(\', "\n                    "found: %r" % (rest,))\n\n\nclass ExtendedInterpolation(Interpolation):\n    """Advanced variant of interpolation, supports the syntax used by\n    `zc.buildout\'. Enables interpolation between sections."""\n\n    _KEYCRE = re.compile(r"\\$\\{([^}]+)\\}")\n\n    def before_get(self, parser, section, option, value, defaults):\n        L = []\n        self._interpolate_some(parser, option, L, value, section, defaults, 1)\n        return \'\'.join(L)\n\n    def before_set(self, parser, section, option, value):\n        tmp_value = value.replace(\'$$\', \'\') # escaped dollar signs\n        tmp_value = self._KEYCRE.sub(\'\', tmp_value) # valid syntax\n        if \'$\' in tmp_value:\n            raise ValueError("invalid interpolation syntax in %r at "\n                             "position %d" % (value, tmp_value.find(\'$\')))\n        return value\n\n    def _interpolate_some(self, parser, option, accum, rest, section, map,\n                          depth):\n        rawval = parser.get(section, option, raw=True, fallback=rest)\n        if depth > MAX_INTERPOLATION_DEPTH:\n            raise InterpolationDepthError(option, section, rawval)\n        while rest:\n            p = rest.find("$")\n            if p < 0:\n                accum.append(rest)\n                return\n            if p > 0:\n                accum.append(rest[:p])\n                rest = rest[p:]\n            # p is no longer used\n            c = rest[1:2]\n            if c == "$":\n                accum.append("$")\n                rest = rest[2:]\n            elif c == "{":\n                m = self._KEYCRE.match(rest)\n                if m is None:\n                    raise InterpolationSyntaxError(option, section,\n                        "bad interpolation variable reference %r" % rest)\n                path = m.group(1).split(\':\')\n                rest = rest[m.end():]\n                sect = section\n                opt = option\n                try:\n                    if len(path) == 1:\n                        opt = parser.optionxform(path[0])\n                        v = map[opt]\n                    elif len(path) == 2:\n                        sect = path[0]\n                        opt = parser.optionxform(path[1])\n                        v = parser.get(sect, opt, raw=True)\n                    else:\n                        raise InterpolationSyntaxError(\n                            option, section,\n                            "More than one \':\' found: %r" % (rest,))\n                except (KeyError, NoSectionError, NoOptionError):\n                    raise InterpolationMissingOptionError(\n                        option, section, rawval, ":".join(path)) from None\n                if "$" in v:\n                    self._interpolate_some(parser, opt, accum, v, sect,\n                                           dict(parser.items(sect, raw=True)),\n                                           depth + 1)\n                else:\n                    accum.append(v)\n            else:\n                raise InterpolationSyntaxError(\n                    option, section,\n                    "\'$\' must be followed by \'$\' or \'{\', "\n                    "found: %r" % (rest,))\n\n\nclass LegacyInterpolation(Interpolation):\n    """Deprecated interpolation used in old versions of ConfigParser.\n    Use BasicInterpolation or ExtendedInterpolation instead."""\n\n    _KEYCRE = re.compile(r"%\\(([^)]*)\\)s|.")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            "LegacyInterpolation has been deprecated since Python 3.2 "\n            "and will be removed from the configparser module in Python 3.13. "\n            "Use BasicInterpolation or ExtendedInterpolation instead.",\n            DeprecationWarning, stacklevel=2\n        )\n\n    def before_get(self, parser, section, option, value, vars):\n        rawval = value\n        depth = MAX_INTERPOLATION_DEPTH\n        while depth:                    # Loop through this until it\'s done\n            depth -= 1\n            if value and "%(" in value:\n                replace = functools.partial(self._interpolation_replace,\n                                            parser=parser)\n                value = self._KEYCRE.sub(replace, value)\n                try:\n                    value = value % vars\n                except KeyError as e:\n                    raise InterpolationMissingOptionError(\n                        option, section, rawval, e.args[0]) from None\n            else:\n                break\n        if value and "%(" in value:\n            raise InterpolationDepthError(option, section, rawval)\n        return value\n\n    def before_set(self, parser, section, option, value):\n        return value\n\n    @staticmethod\n    def _interpolation_replace(match, parser):\n        s = match.group(1)\n        if s is None:\n            return match.group()\n        else:\n            return "%%(%s)s" % parser.optionxform(s)\n\n\nclass RawConfigParser(MutableMapping):\n    """ConfigParser that does not do interpolation."""\n\n    # Regular expressions for parsing section headers and options\n    _SECT_TMPL = r"""\n        \\[                                 # [\n        (?P<header>.+)                     # very permissive!\n        \\]                                 # ]\n        """\n    _OPT_TMPL = r"""\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?P<vi>{delim})\\s*              # any number of space/tab,\n                                           # followed by any of the\n                                           # allowed delimiters,\n                                           # followed by any space/tab\n        (?P<value>.*)$                     # everything up to eol\n        """\n    _OPT_NV_TMPL = r"""\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?:                             # any number of space/tab,\n        (?P<vi>{delim})\\s*                 # optionally followed by\n                                           # any of the allowed\n                                           # delimiters, followed by any\n                                           # space/tab\n        (?P<value>.*))?$                   # everything up to eol\n        """\n    # Interpolation algorithm to be used if the user does not specify another\n    _DEFAULT_INTERPOLATION = Interpolation()\n    # Compiled regular expression for matching sections\n    SECTCRE = re.compile(_SECT_TMPL, re.VERBOSE)\n    # Compiled regular expression for matching options with typical separators\n    OPTCRE = re.compile(_OPT_TMPL.format(delim="=|:"), re.VERBOSE)\n    # Compiled regular expression for matching options with optional values\n    # delimited using typical separators\n    OPTCRE_NV = re.compile(_OPT_NV_TMPL.format(delim="=|:"), re.VERBOSE)\n    # Compiled regular expression for matching leading whitespace in a line\n    NONSPACECRE = re.compile(r"\\S")\n    # Possible boolean values in the configuration.\n    BOOLEAN_STATES = {\'1\': True, \'yes\': True, \'true\': True, \'on\': True,\n                      \'0\': False, \'no\': False, \'false\': False, \'off\': False}\n\n    def __init__(self, defaults=None, dict_type=_default_dict,\n                 allow_no_value=False, *, delimiters=(\'=\', \':\'),\n                 comment_prefixes=(\'#\', \';\'), inline_comment_prefixes=None,\n                 strict=True, empty_lines_in_values=True,\n                 default_section=DEFAULTSECT,\n                 interpolation=_UNSET, converters=_UNSET):\n\n        self._dict = dict_type\n        self._sections = self._dict()\n        self._defaults = self._dict()\n        self._converters = ConverterMapping(self)\n        self._proxies = self._dict()\n        self._proxies[default_section] = SectionProxy(self, default_section)\n        self._delimiters = tuple(delimiters)\n        if delimiters == (\'=\', \':\'):\n            self._optcre = self.OPTCRE_NV if allow_no_value else self.OPTCRE\n        else:\n            d = "|".join(re.escape(d) for d in delimiters)\n            if allow_no_value:\n                self._optcre = re.compile(self._OPT_NV_TMPL.format(delim=d),\n                                          re.VERBOSE)\n            else:\n                self._optcre = re.compile(self._OPT_TMPL.format(delim=d),\n                                          re.VERBOSE)\n        self._comment_prefixes = tuple(comment_prefixes or ())\n        self._inline_comment_prefixes = tuple(inline_comment_prefixes or ())\n        self._strict = strict\n        self._allow_no_value = allow_no_value\n        self._empty_lines_in_values = empty_lines_in_values\n        self.default_section=default_section\n        self._interpolation = interpolation\n        if self._interpolation is _UNSET:\n            self._interpolation = self._DEFAULT_INTERPOLATION\n        if self._interpolation is None:\n            self._interpolation = Interpolation()\n        if not isinstance(self._interpolation, Interpolation):\n            raise TypeError(\n                f"interpolation= must be None or an instance of Interpolation;"\n                f" got an object of type {type(self._interpolation)}"\n            )\n        if converters is not _UNSET:\n            self._converters.update(converters)\n        if defaults:\n            self._read_defaults(defaults)\n\n    def defaults(self):\n        return self._defaults\n\n    def sections(self):\n        """Return a list of section names, excluding [DEFAULT]"""\n        # self._sections will never have [DEFAULT] in it\n        return list(self._sections.keys())\n\n    def add_section(self, section):\n        """Create a new section in the configuration.\n\n        Raise DuplicateSectionError if a section by the specified name\n        already exists. Raise ValueError if name is DEFAULT.\n        """\n        if section == self.default_section:\n            raise ValueError(\'Invalid section name: %r\' % section)\n\n        if section in self._sections:\n            raise DuplicateSectionError(section)\n        self._sections[section] = self._dict()\n        self._proxies[section] = SectionProxy(self, section)\n\n    def has_section(self, section):\n        """Indicate whether the named section is present in the configuration.\n\n        The DEFAULT section is not acknowledged.\n        """\n        return section in self._sections\n\n    def options(self, section):\n        """Return a list of option names for the given section name."""\n        try:\n            opts = self._sections[section].copy()\n        except KeyError:\n            raise NoSectionError(section) from None\n        opts.update(self._defaults)\n        return list(opts.keys())\n\n    def read(self, filenames, encoding=None):\n        """Read and parse a filename or an iterable of filenames.\n\n        Files that cannot be opened are silently ignored; this is\n        designed so that you can specify an iterable of potential\n        configuration file locations (e.g. current directory, user\'s\n        home directory, systemwide directory), and all existing\n        configuration files in the iterable will be read.  A single\n        filename may also be given.\n\n        Return list of successfully read files.\n        """\n        if isinstance(filenames, (str, bytes, os.PathLike)):\n            filenames = [filenames]\n        encoding = io.text_encoding(encoding)\n        read_ok = []\n        for filename in filenames:\n            try:\n                with open(filename, encoding=encoding) as fp:\n                    self._read(fp, filename)\n            except OSError:\n                continue\n            if isinstance(filename, os.PathLike):\n                filename = os.fspath(filename)\n            read_ok.append(filename)\n        return read_ok\n\n    def read_file(self, f, source=None):\n        """Like read() but the argument must be a file-like object.\n\n        The `f\' argument must be iterable, returning one line at a time.\n        Optional second argument is the `source\' specifying the name of the\n        file being read. If not given, it is taken from f.name. If `f\' has no\n        `name\' attribute, `<???>\' is used.\n        """\n        if source is None:\n            try:\n                source = f.name\n            except AttributeError:\n                source = \'<???>\'\n        self._read(f, source)\n\n    def read_string(self, string, source=\'<string>\'):\n        """Read configuration from a given string."""\n        sfile = io.StringIO(string)\n        self.read_file(sfile, source)\n\n    def read_dict(self, dictionary, source=\'<dict>\'):\n        """Read configuration from a dictionary.\n\n        Keys are section names, values are dictionaries with keys and values\n        that should be present in the section. If the used dictionary type\n        preserves order, sections and their keys will be added in order.\n\n        All types held in the dictionary are converted to strings during\n        reading, including section names, option names and keys.\n\n        Optional second argument is the `source\' specifying the name of the\n        dictionary being read.\n        """\n        elements_added = set()\n        for section, keys in dictionary.items():\n            section = str(section)\n            try:\n                self.add_section(section)\n            except (DuplicateSectionError, ValueError):\n                if self._strict and section in elements_added:\n                    raise\n            elements_added.add(section)\n            for key, value in keys.items():\n                key = self.optionxform(str(key))\n                if value is not None:\n                    value = str(value)\n                if self._strict and (section, key) in elements_added:\n                    raise DuplicateOptionError(section, key, source)\n                elements_added.add((section, key))\n                self.set(section, key, value)\n\n    def readfp(self, fp, filename=None):\n        """Deprecated, use read_file instead."""\n        warnings.warn(\n            "This method will be removed in Python 3.12. "\n            "Use \'parser.read_file()\' instead.",\n            DeprecationWarning, stacklevel=2\n        )\n        self.read_file(fp, source=filename)\n\n    def get(self, section, option, *, raw=False, vars=None, fallback=_UNSET):\n        """Get an option value for a given section.\n\n        If `vars\' is provided, it must be a dictionary. The option is looked up\n        in `vars\' (if provided), `section\', and in `DEFAULTSECT\' in that order.\n        If the key is not found and `fallback\' is provided, it is used as\n        a fallback value. `None\' can be provided as a `fallback\' value.\n\n        If interpolation is enabled and the optional argument `raw\' is False,\n        all interpolations are expanded in the return values.\n\n        Arguments `raw\', `vars\', and `fallback\' are keyword only.\n\n        The section DEFAULT is special.\n        """\n        try:\n            d = self._unify_values(section, vars)\n        except NoSectionError:\n            if fallback is _UNSET:\n                raise\n            else:\n                return fallback\n        option = self.optionxform(option)\n        try:\n            value = d[option]\n        except KeyError:\n            if fallback is _UNSET:\n                raise NoOptionError(option, section)\n            else:\n                return fallback\n\n        if raw or value is None:\n            return value\n        else:\n            return self._interpolation.before_get(self, section, option, value,\n                                                  d)\n\n    def _get(self, section, conv, option, **kwargs):\n        return conv(self.get(section, option, **kwargs))\n\n    def _get_conv(self, section, option, conv, *, raw=False, vars=None,\n                  fallback=_UNSET, **kwargs):\n        try:\n            return self._get(section, conv, option, raw=raw, vars=vars,\n                             **kwargs)\n        except (NoSectionError, NoOptionError):\n            if fallback is _UNSET:\n                raise\n            return fallback\n\n    # getint, getfloat and getboolean provided directly for backwards compat\n    def getint(self, section, option, *, raw=False, vars=None,\n               fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, int, raw=raw, vars=vars,\n                              fallback=fallback, **kwargs)\n\n    def getfloat(self, section, option, *, raw=False, vars=None,\n                 fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, float, raw=raw, vars=vars,\n                              fallback=fallback, **kwargs)\n\n    def getboolean(self, section, option, *, raw=False, vars=None,\n                   fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, self._convert_to_boolean,\n                              raw=raw, vars=vars, fallback=fallback, **kwargs)\n\n    def items(self, section=_UNSET, raw=False, vars=None):\n        """Return a list of (name, value) tuples for each option in a section.\n\n        All % interpolations are expanded in the return values, based on the\n        defaults passed into the constructor, unless the optional argument\n        `raw\' is true.  Additional substitutions may be provided using the\n        `vars\' argument, which must be a dictionary whose contents overrides\n        any pre-existing defaults.\n\n        The section DEFAULT is special.\n        """\n        if section is _UNSET:\n            return super().items()\n        d = self._defaults.copy()\n        try:\n            d.update(self._sections[section])\n        except KeyError:\n            if section != self.default_section:\n                raise NoSectionError(section)\n        orig_keys = list(d.keys())\n        # Update with the entry specific variables\n        if vars:\n            for key, value in vars.items():\n                d[self.optionxform(key)] = value\n        value_getter = lambda option: self._interpolation.before_get(self,\n            section, option, d[option], d)\n        if raw:\n            value_getter = lambda option: d[option]\n        return [(option, value_getter(option)) for option in orig_keys]\n\n    def popitem(self):\n        """Remove a section from the parser and return it as\n        a (section_name, section_proxy) tuple. If no section is present, raise\n        KeyError.\n\n        The section DEFAULT is never returned because it cannot be removed.\n        """\n        for key in self.sections():\n            value = self[key]\n            del self[key]\n            return key, value\n        raise KeyError\n\n    def optionxform(self, optionstr):\n        return optionstr.lower()\n\n    def has_option(self, section, option):\n        """Check for the existence of a given option in a given section.\n        If the specified `section\' is None or an empty string, DEFAULT is\n        assumed. If the specified `section\' does not exist, returns False."""\n        if not section or section == self.default_section:\n            option = self.optionxform(option)\n            return option in self._defaults\n        elif section not in self._sections:\n            return False\n        else:\n            option = self.optionxform(option)\n            return (option in self._sections[section]\n                    or option in self._defaults)\n\n    def set(self, section, option, value=None):\n        """Set an option."""\n        if value:\n            value = self._interpolation.before_set(self, section, option,\n                                                   value)\n        if not section or section == self.default_section:\n            sectdict = self._defaults\n        else:\n            try:\n                sectdict = self._sections[section]\n            except KeyError:\n                raise NoSectionError(section) from None\n        sectdict[self.optionxform(option)] = value\n\n    def write(self, fp, space_around_delimiters=True):\n        """Write an .ini-format representation of the configuration state.\n\n        If `space_around_delimiters\' is True (the default), delimiters\n        between keys and values are surrounded by spaces.\n\n        Please note that comments in the original configuration file are not\n        preserved when writing the configuration back.\n        """\n        if space_around_delimiters:\n            d = " {} ".format(self._delimiters[0])\n        else:\n            d = self._delimiters[0]\n        if self._defaults:\n            self._write_section(fp, self.default_section,\n                                    self._defaults.items(), d)\n        for section in self._sections:\n            self._write_section(fp, section,\n                                self._sections[section].items(), d)\n\n    def _write_section(self, fp, section_name, section_items, delimiter):\n        """Write a single section to the specified `fp\'."""\n        fp.write("[{}]\\n".format(section_name))\n        for key, value in section_items:\n            value = self._interpolation.before_write(self, section_name, key,\n                                                     value)\n            if value is not None or not self._allow_no_value:\n                value = delimiter + str(value).replace(\'\\n\', \'\\n\\t\')\n            else:\n                value = ""\n            fp.write("{}{}\\n".format(key, value))\n        fp.write("\\n")\n\n    def remove_option(self, section, option):\n        """Remove an option."""\n        if not section or section == self.default_section:\n            sectdict = self._defaults\n        else:\n            try:\n                sectdict = self._sections[section]\n            except KeyError:\n                raise NoSectionError(section) from None\n        option = self.optionxform(option)\n        existed = option in sectdict\n        if existed:\n            del sectdict[option]\n        return existed\n\n    def remove_section(self, section):\n        """Remove a file section."""\n        existed = section in self._sections\n        if existed:\n            del self._sections[section]\n            del self._proxies[section]\n        return existed\n\n    def __getitem__(self, key):\n        if key != self.default_section and not self.has_section(key):\n            raise KeyError(key)\n        return self._proxies[key]\n\n    def __setitem__(self, key, value):\n        # To conform with the mapping protocol, overwrites existing values in\n        # the section.\n        if key in self and self[key] is value:\n            return\n        # XXX this is not atomic if read_dict fails at any point. Then again,\n        # no update method in configparser is atomic in this implementation.\n        if key == self.default_section:\n            self._defaults.clear()\n        elif key in self._sections:\n            self._sections[key].clear()\n        self.read_dict({key: value})\n\n    def __delitem__(self, key):\n        if key == self.default_section:\n            raise ValueError("Cannot remove the default section.")\n        if not self.has_section(key):\n            raise KeyError(key)\n        self.remove_section(key)\n\n    def __contains__(self, key):\n        return key == self.default_section or self.has_section(key)\n\n    def __len__(self):\n        return len(self._sections) + 1 # the default section\n\n    def __iter__(self):\n        # XXX does it break when underlying container state changed?\n        return itertools.chain((self.default_section,), self._sections.keys())\n\n    def _read(self, fp, fpname):\n        """Parse a sectioned configuration file.\n\n        Each section in a configuration file contains a header, indicated by\n        a name in square brackets (`[]\'), plus key/value options, indicated by\n        `name\' and `value\' delimited with a specific substring (`=\' or `:\' by\n        default).\n\n        Values can span multiple lines, as long as they are indented deeper\n        than the first line of the value. Depending on the parser\'s mode, blank\n        lines may be treated as parts of multiline values or ignored.\n\n        Configuration files may include comments, prefixed by specific\n        characters (`#\' and `;\' by default). Comments may appear on their own\n        in an otherwise empty line or may be entered in lines holding values or\n        section names. Please note that comments get stripped off when reading configuration files.\n        """\n        elements_added = set()\n        cursect = None                        # None, or a dictionary\n        sectname = None\n        optname = None\n        lineno = 0\n        indent_level = 0\n        e = None                              # None, or an exception\n        for lineno, line in enumerate(fp, start=1):\n            comment_start = sys.maxsize\n            # strip inline comments\n            inline_prefixes = {p: -1 for p in self._inline_comment_prefixes}\n            while comment_start == sys.maxsize and inline_prefixes:\n                next_prefixes = {}\n                for prefix, index in inline_prefixes.items():\n                    index = line.find(prefix, index+1)\n                    if index == -1:\n                        continue\n                    next_prefixes[prefix] = index\n                    if index == 0 or (index > 0 and line[index-1].isspace()):\n                        comment_start = min(comment_start, index)\n                inline_prefixes = next_prefixes\n            # strip full line comments\n            for prefix in self._comment_prefixes:\n                if line.strip().startswith(prefix):\n                    comment_start = 0\n                    break\n            if comment_start == sys.maxsize:\n                comment_start = None\n            value = line[:comment_start].strip()\n            if not value:\n                if self._empty_lines_in_values:\n                    # add empty line to the value, but only if there was no\n                    # comment on the line\n                    if (comment_start is None and\n                        cursect is not None and\n                        optname and\n                        cursect[optname] is not None):\n                        cursect[optname].append(\'\') # newlines added at join\n                else:\n                    # empty line marks end of value\n                    indent_level = sys.maxsize\n                continue\n            # continuation line?\n            first_nonspace = self.NONSPACECRE.search(line)\n            cur_indent_level = first_nonspace.start() if first_nonspace else 0\n            if (cursect is not None and optname and\n                cur_indent_level > indent_level):\n                cursect[optname].append(value)\n            # a section header or option header?\n            else:\n                indent_level = cur_indent_level\n                # is it a section header?\n                mo = self.SECTCRE.match(value)\n                if mo:\n                    sectname = mo.group(\'header\')\n                    if sectname in self._sections:\n                        if self._strict and sectname in elements_added:\n                            raise DuplicateSectionError(sectname, fpname,\n                                                        lineno)\n                        cursect = self._sections[sectname]\n                        elements_added.add(sectname)\n                    elif sectname == self.default_section:\n                        cursect = self._defaults\n                    else:\n                        cursect = self._dict()\n                        self._sections[sectname] = cursect\n                        self._proxies[sectname] = SectionProxy(self, sectname)\n                        elements_added.add(sectname)\n                    # So sections can\'t start with a continuation line\n                    optname = None\n                # no section header in the file?\n                elif cursect is None:\n                    raise MissingSectionHeaderError(fpname, lineno, line)\n                # an option line?\n                else:\n                    mo = self._optcre.match(value)\n                    if mo:\n                        optname, vi, optval = mo.group(\'option\', \'vi\', \'value\')\n                        if not optname:\n                            e = self._handle_error(e, fpname, lineno, line)\n                        optname = self.optionxform(optname.rstrip())\n                        if (self._strict and\n                            (sectname, optname) in elements_added):\n                            raise DuplicateOptionError(sectname, optname,\n                                                       fpname, lineno)\n                        elements_added.add((sectname, optname))\n                        # This check is fine because the OPTCRE cannot\n                        # match if it would set optval to None\n                        if optval is not None:\n                            optval = optval.strip()\n                            cursect[optname] = [optval]\n                        else:\n                            # valueless option handling\n                            cursect[optname] = None\n                    else:\n                        # a non-fatal parsing error occurred. set up the\n                        # exception but keep going. the exception will be\n                        # raised at the end of the file and will contain a\n                        # list of all bogus lines\n                        e = self._handle_error(e, fpname, lineno, line)\n        self._join_multiline_values()\n        # if any parsing errors occurred, raise an exception\n        if e:\n            raise e\n\n    def _join_multiline_values(self):\n        defaults = self.default_section, self._defaults\n        all_sections = itertools.chain((defaults,),\n                                       self._sections.items())\n        for section, options in all_sections:\n            for name, val in options.items():\n                if isinstance(val, list):\n                    val = \'\\n\'.join(val).rstrip()\n                options[name] = self._interpolation.before_read(self,\n                                                                section,\n                                                                name, val)\n\n    def _read_defaults(self, defaults):\n        """Read the defaults passed in the initializer.\n        Note: values can be non-string."""\n        for key, value in defaults.items():\n            self._defaults[self.optionxform(key)] = value\n\n    def _handle_error(self, exc, fpname, lineno, line):\n        if not exc:\n            exc = ParsingError(fpname)\n        exc.append(lineno, repr(line))\n        return exc\n\n    def _unify_values(self, section, vars):\n        """Create a sequence of lookups with \'vars\' taking priority over\n        the \'section\' which takes priority over the DEFAULTSECT.\n\n        """\n        sectiondict = {}\n        try:\n            sectiondict = self._sections[section]\n        except KeyError:\n            if section != self.default_section:\n                raise NoSectionError(section) from None\n        # Update with the entry specific variables\n        vardict = {}\n        if vars:\n            for key, value in vars.items():\n                if value is not None:\n                    value = str(value)\n                vardict[self.optionxform(key)] = value\n        return _ChainMap(vardict, sectiondict, self._defaults)\n\n    def _convert_to_boolean(self, value):\n        """Return a boolean value translating from other types if necessary.\n        """\n        if value.lower() not in self.BOOLEAN_STATES:\n            raise ValueError(\'Not a boolean: %s\' % value)\n        return self.BOOLEAN_STATES[value.lower()]\n\n    def _validate_value_types(self, *, section="", option="", value=""):\n        """Raises a TypeError for non-string values.\n\n        The only legal non-string value if we allow valueless\n        options is None, so we need to check if the value is a\n        string if:\n        - we do not allow valueless options, or\n        - we allow valueless options but the value is not None\n\n        For compatibility reasons this method is not used in classic set()\n        for RawConfigParsers. It is invoked in every case for mapping protocol\n        access and in ConfigParser.set().\n        """\n        if not isinstance(section, str):\n            raise TypeError("section names must be strings")\n        if not isinstance(option, str):\n            raise TypeError("option keys must be strings")\n        if not self._allow_no_value or value:\n            if not isinstance(value, str):\n                raise TypeError("option values must be strings")\n\n    @property\n    def converters(self):\n        return self._converters\n\n\nclass ConfigParser(RawConfigParser):\n    """ConfigParser implementing interpolation."""\n\n    _DEFAULT_INTERPOLATION = BasicInterpolation()\n\n    def set(self, section, option, value=None):\n        """Set an option.  Extends RawConfigParser.set by validating type and\n        interpolation syntax on the value."""\n        self._validate_value_types(option=option, value=value)\n        super().set(section, option, value)\n\n    def add_section(self, section):\n        """Create a new section in the configuration.  Extends\n        RawConfigParser.add_section by validating if the section name is\n        a string."""\n        self._validate_value_types(section=section)\n        super().add_section(section)\n\n    def _read_defaults(self, defaults):\n        """Reads the defaults passed in the initializer, implicitly converting\n        values to strings like the rest of the API.\n\n        Does not perform interpolation for backwards compatibility.\n        """\n        try:\n            hold_interpolation = self._interpolation\n            self._interpolation = Interpolation()\n            self.read_dict({self.default_section: defaults})\n        finally:\n            self._interpolation = hold_interpolation\n\n\nclass SafeConfigParser(ConfigParser):\n    """ConfigParser alias for backwards compatibility purposes."""\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            "The SafeConfigParser class has been renamed to ConfigParser "\n            "in Python 3.2. This alias will be removed in Python 3.12."\n            " Use ConfigParser directly instead.",\n            DeprecationWarning, stacklevel=2\n        )\n\n\nclass SectionProxy(MutableMapping):\n    """A proxy for a single section from a parser."""\n\n    def __init__(self, parser, name):\n        """Creates a view on a section of the specified `name` in `parser`."""\n        self._parser = parser\n        self._name = name\n        for conv in parser.converters:\n            key = \'get\' + conv\n            getter = functools.partial(self.get, _impl=getattr(parser, key))\n            setattr(self, key, getter)\n\n    def __repr__(self):\n        return \'<Section: {}>\'.format(self._name)\n\n    def __getitem__(self, key):\n        if not self._parser.has_option(self._name, key):\n            raise KeyError(key)\n        return self._parser.get(self._name, key)\n\n    def __setitem__(self, key, value):\n        self._parser._validate_value_types(option=key, value=value)\n        return self._parser.set(self._name, key, value)\n\n    def __delitem__(self, key):\n        if not (self._parser.has_option(self._name, key) and\n                self._parser.remove_option(self._name, key)):\n            raise KeyError(key)\n\n    def __contains__(self, key):\n        return self._parser.has_option(self._name, key)\n\n    def __len__(self):\n        return len(self._options())\n\n    def __iter__(self):\n        return self._options().__iter__()\n\n    def _options(self):\n        if self._name != self._parser.default_section:\n            return self._parser.options(self._name)\n        else:\n            return self._parser.defaults()\n\n    @property\n    def parser(self):\n        # The parser object of the proxy is read-only.\n        return self._parser\n\n    @property\n    def name(self):\n        # The name of the section on a proxy is read-only.\n        return self._name\n\n    def get(self, option, fallback=None, *, raw=False, vars=None,\n            _impl=None, **kwargs):\n        """Get an option value.\n\n        Unless `fallback` is provided, `None` will be returned if the option\n        is not found.\n\n        """\n        # If `_impl` is provided, it should be a getter method on the parser\n        # object that provides the desired type conversion.\n        if not _impl:\n            _impl = self._parser.get\n        return _impl(self._name, option, raw=raw, vars=vars,\n                     fallback=fallback, **kwargs)\n\n\nclass ConverterMapping(MutableMapping):\n    """Enables reuse of get*() methods between the parser and section proxies.\n\n    If a parser class implements a getter directly, the value for the given\n    key will be ``None``. The presence of the converter name here enables\n    section proxies to find and use the implementation on the parser class.\n    """\n\n    GETTERCRE = re.compile(r"^get(?P<name>.+)$")\n\n    def __init__(self, parser):\n        self._parser = parser\n        self._data = {}\n        for getter in dir(self._parser):\n            m = self.GETTERCRE.match(getter)\n            if not m or not callable(getattr(self._parser, getter)):\n                continue\n            self._data[m.group(\'name\')] = None   # See class docstring.\n\n    def __getitem__(self, key):\n        return self._data[key]\n\n    def __setitem__(self, key, value):\n        try:\n            k = \'get\' + key\n        except TypeError:\n            raise ValueError(\'Incompatible key: {} (type: {})\'\n                             \'\'.format(key, type(key)))\n        if k == \'get\':\n            raise ValueError(\'Incompatible key: cannot use "" as a name\')\n        self._data[key] = value\n        func = functools.partial(self._parser._get_conv, conv=value)\n        func.converter = value\n        setattr(self._parser, k, func)\n        for proxy in self._parser.values():\n            getter = functools.partial(proxy.get, _impl=func)\n            setattr(proxy, k, getter)\n\n    def __delitem__(self, key):\n        try:\n            k = \'get\' + (key or None)\n        except TypeError:\n            raise KeyError(key)\n        del self._data[key]\n        for inst in itertools.chain((self._parser,), self._parser.values()):\n            try:\n                delattr(inst, k)\n            except AttributeError:\n                # don\'t raise since the entry was present in _data, silently\n                # clean up\n                continue\n\n    def __iter__(self):\n        return iter(self._data)\n\n    def __len__(self):\n        return len(self._data)\n')
    __stickytape_write_module('language.py', b'\nEN = "en"\nJA = "ja"\n\nLanguage = {\n    "en": {\n        "help": "Help",\n        "send_code": "Send",\n        "disable_code": "Disable",\n        "pls_enter_ip": "Please enter your WiiU IPAddress",\n        "ip_address": "IP Address",\n        "connecting": "Connecting...",\n        "connected": "Connected",\n        "main_connected": "Connected",\n        "main_no_connection": "NoConnection",\n        "disconnected": "Disconnected",\n        "error_screenshot": "An error has occurred. The error message will be displayed in 5 seconds. Please send a screenshot to iranjin#4548.",\n        "tcp_status": "TCPStatus",\n        "tab": {\n            "send": "Send",\n            "disable": "Disable",\n            "connect": "Connect/Disconnect",\n            "code_manager": "CodeManager",\n        },\n    },\n    "ja": {\n        "help": "\xe3\x83\x98\xe3\x83\xab\xe3\x83\x97",\n        "send_code": "\xe9\x80\x81\xe4\xbf\xa1",\n        "disable_code": "\xe8\xa7\xa3\xe9\x99\xa4",\n        "pls_enter_ip": "WiiU\xe3\x81\xaeIP\xe3\x82\xa2\xe3\x83\x89\xe3\x83\xac\xe3\x82\xb9\xe3\x82\x92\xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84",\n        "ip_address": "IP\xe3\x82\xa2\xe3\x83\x89\xe3\x83\xac\xe3\x82\xb9",\n        "connecting": "\xe6\x8e\xa5\xe7\xb6\x9a\xe4\xb8\xad...",\n        "connected": "\xe6\x8e\xa5\xe7\xb6\x9a\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f",\n        "main_connected": "\xe6\x8e\xa5\xe7\xb6\x9a\xe6\xb8\x88\xe3\x81\xbf",\n        "main_no_connection": "\xe9\x9d\x9e\xe6\x8e\xa5\xe7\xb6\x9a",\n        "disconnected": "\xe5\x88\x87\xe6\x96\xad\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f",\n        "error_screenshot": "\xe3\x82\xa8\xe3\x83\xa9\xe3\x83\xbc\xe3\x81\x8c\xe7\x99\xba\xe7\x94\x9f\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f\xe3\x80\x82\xe3\x82\xa8\xe3\x83\xa9\xe3\x83\xbc\xe3\x83\xa1\xe3\x83\x83\xe3\x82\xbb\xe3\x83\xbc\xe3\x82\xb8\xe3\x81\x8c5\xe7\xa7\x92\xe5\xbe\x8c\xe3\x81\xab\xe8\xa1\xa8\xe7\xa4\xba\xe3\x81\x95\xe3\x82\x8c\xe3\x81\xbe\xe3\x81\x99\xe3\x80\x82\xe3\x82\xb9\xe3\x82\xaf\xe3\x83\xaa\xe3\x83\xbc\xe3\x83\xb3\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x82\x92iranjin#4548\xe3\x81\xab\xe9\x80\x81\xe4\xbf\xa1\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84\xe3\x80\x82",\n        "tcp_status": "TCP\xe3\x82\xb9\xe3\x83\x86\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xb9",\n        "tab": {\n            "send": "\xe9\x80\x81\xe4\xbf\xa1",\n            "disable": "\xe8\xa7\xa3\xe9\x99\xa4",\n            "connect": "\xe6\x8e\xa5\xe7\xb6\x9a/\xe5\x88\x87\xe6\x96\xad",\n            "code_manager": "\xe3\x82\xb3\xe3\x83\xbc\xe3\x83\x89\xe3\x83\x9e\xe3\x83\x8d\xe3\x83\xbc\xe3\x82\xb8\xe3\x83\xa3\xe3\x83\xbc",\n        },\n    }\n}\n')
    __stickytape_write_module('tcp.py', b'\nimport socket\nimport struct\nimport re\n\nfrom enum import Enum\nfrom cstr import *\n\nclass CMD(Enum):\n    POKE_8                      = b\'\\x01\'\n    POKE_16                     = b\'\\x02\'\n    POKE_32                     = b\'\\x03\'\n    READ_MEMORY                 = b\'\\x04\'\n    READ_MEMORY_KERNEL          = b\'\\x05\'\n    VALIDATE_ADDRESS_RANGE      = b\'\\x06\'\n    MEMORY_DISASSEMBLE          = b\'\\x08\'\n    # READ_MEMORY_COMPRESSED    = b\'\\x09\'\n    KERNEL_WRITE                = b\'\\x0B\' \n    KERNEL_READ                 = b\'\\x0C\'\n    # TAKE_SCREENSHOT            = b\'\\x0D\'\n    UPLOAD_MEMORY               = b\'\\x41\'\n    SERVER_STATUS               = b\'\\x50\'\n    GET_DATA_BUFFER_SIZE        = b\'\\x51\'\n    READ_FILE                   = b\'\\x52\'\n    READ_DIRECTORY              = b\'\\x53\'\n    REPLACE_FILE                = b\'\\x54\'\n    GET_CODE_HANDLER_ADDRESS    = b\'\\x55\'\n    READ_THREADS                = b\'\\x56\'\n    ACCOUNT_IDENTIFIER          = b\'\\x57\'\n    # WRITE_SCREEN              = b\'\\x58\'\n    FOLLOW_POINTER              = b\'\\x60\'\n    REMOTE_PROCEDURE_CALL       = b\'\\x70\'\n    GET_SYMBOL                  = b\'\\x71\'\n    MEMORY_SEARCH               = b\'\\x72\'\n    ADVANCED_MEMORY_SEARCH      = b\'\\x73\'\n    EXECUTE_ASSEMBLY            = b\'\\x81\'\n    PAUSE_CONSOLE               = b\'\\x82\'\n    RESUME_CONSOLE              = b\'\\x83\'\n    IS_CONSOLE_PAUSED           = b\'\\x84\'\n    GET_SERVER_VERSION          = b\'\\x99\'\n    GET_OS_VERSION              = b\'\\x9A\'\n    SET_DATA_BREAKPOINT         = b\'\\xA0\'\n    SET_INSTRUCTION_BREAKPOINT  = b\'\\xA2\'\n    TOGGLE_BREAKPOINT           = b\'\\xA5\'\n    REMOVE_ALL_BREAKPOINT       = b\'\\xA6\'\n    POKE_REGISTERS              = b\'\\xA7\'\n    GET_STACK_TRACE             = b\'\\xA8\'\n    GET_ENTRY_POINT_ADDRESS     = b\'\\xB1\'\n    RUN_KERNEL_COPY_SERVICE     = b\'\\xCD\'\n    IOSU_HAX_READ_FILE          = b\'\\xD0\'\n    GET_VERSION_HASH            = b\'\\xE0\'\n    PERSIST_ASSEMBLY            = b\'\\xE1\'\n    CLEAR_ASSEMBLY              = b\'\\xE2\'\n\n\n\nclass TCPGecko:\n\n    def __init__(self, ip_address: str = None, port: int = 7331, clear_cafe: bool = False):\n        self.__timeout = 5.0\n        self.__connected = False\n        self.__ip_address = None\n        self.__port = port\n        self.clear_cafe = clear_cafe\n        if ip_address:\n            self.setIpAddress(ip_address)\n        self.socketInit()\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.__connected:\n            self.disconnect()\n    \n    \n    def socketInit(self):\n        self.__connected = False\n        self.__s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        return self\n\n\n    def setTimeout(self, timeout: float):\n        self.__timeout = timeout\n\n        return self\n    \n\n    def setIpAddress(self, ip_address: str, port: int = 7331):\n        if re.match(r\'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$\', ip_address) is None:\n            raise ValueError("Invalid ip address format \'%s\'" % (ip_address))\n        self.__ip_address = ip_address\n        self.__port = port\n\n        return self\n\n\n    @property\n    def ip_address(self):\n        return self.__ip_address\n    \n\n    def connect(self, ip_address: str = None, port: int = None, timeout: float = None):\n        if self.__connected:\n            return self\n        \n        self.__s.settimeout((timeout if timeout else self.__timeout))\n\n        try:\n            self.__s.connect((\n                (ip_address if ip_address else self.__ip_address),\n                ((port if port else self.__port))))\n        except TimeoutError as e:\n            self.__connected = False\n            raise e\n        else:\n            self.__ip_address = ip_address\n            self.__connected = True\n\n        return self\n\n\n    def disconnect(self):\n        self.__connected = False\n\n        if not self.__connected:\n            return self\n\n        self.__s.close()\n\n        return self\n    \n\n    def isConnected(self):\n        return self.__connected\n    \n\n    def getTitleId(self):...\n\n\n    def poke(\n            self,\n            address: int,\n            value: int,\n            size: int = 32\n        ):\n\n        if   size == 8:  cmd = CMD.POKE_8\n        elif size == 16: cmd = CMD.POKE_16\n        elif size == 32: cmd = CMD.POKE_32\n        else:\n            raise ValueError("Invalid int value size: %d" % (size))\n\n        self.__s.send(cmd)\n        self.__s.send(struct.pack("\\\\II", address, value))\n\n        return self\n\n    \n    def assemblyRamWrite(self, _asm_code: cstr):\n        asm_code = cstr(_asm_code.replace("#", ""))\n\n        if not (asm_code or asm_code.isCode()):\n            raise ValueError("The code is invalid: %s" % (asm_code))\n        \n        code = asm_code.formatCode().splitRamWrite()\n\n        for line in code:\n            self.poke(line[0], line[1])\n        \n        return self\n    \n    \n    def sendCafeCode(self, _cafe_code: cstr):\n        cafe_code = cstr(_cafe_code.replace("#", ""))\n\n        if not (cafe_code or cafe_code.isCode()):\n            raise ValueError("The code is invalid: %s" % (cafe_code))\n        \n        code = cafe_code.formatCode().splitCafeCode()\n        code.append(0x0)\n\n        self.switchCafeCode(False)\n\n        for i, value in enumerate(code):\n            self.poke(0x01133000 + i * 4, value)\n\n        self.switchCafeCode(True)\n\n        return self\n    \n\n    def switchCafeCode(self, switch: bool):\n        self.poke(0x10014CFC, (0x1 if switch else 0x0))\n\n        return self\n    \n\n    def disableCafeCode(self):\n        self.switchCafeCode(False)\n        if self.clear_cafe:\n            self.__clearCafeCode()\n\n        return self\n\n\n    def __clearCafeCode(self, _range: int = 2656):\n        for i in range(_range):\n            self.poke(0x01133000 + i * 4, 0x0)\n')
    __stickytape_write_module('terminal.py', b'\nimport platform\nimport os\n\nfrom misc import *\n\nclass Terminal:\n    \n    def __init__(self, line: int = 99):\n        self.__clear_command = None\n        self.__line = line\n\n        self.__getClearCmd()\n    \n\n    def __getClearCmd(self):\n        sys = platform.system()\n        pf = platform.platform()\n\n        if "iOS" in pf:\n            self.__clear_command = None\n            return None\n        \n        if sys == "Windows":\n            self.__clear_command = "cls"\n            return "Windows"\n        elif sys == "Darwin":\n            self.__clear_command = "clear"\n            return "macos"\n        elif sys == "Linux":\n            self.__clear_command = "clear"\n            return "linux"\n        else:\n            self.__clear_command = None\n            return None\n        \n\n    def cls(self):\n        if not self.__clear_command:\n            print("\\n" * self.__line)\n            return\n        os.system(self.__clear_command)\n\n\n    @staticmethod\n    def elementSelecter(elements: list, msg: str, _exit: bool = False):\n        elements = list(elements)\n\n        if not elements:\n            return None\n\n        t = Terminal()\n\n        while True:\n            t.cls()\n\n            for i, element in enumerate(elements):\n                print("%s \xe2\x94\x82 %s" % (\n                        str(i + 1).rjust(digit(len(elements))), element))\n            \n            index_s = input("%s \\\\ " % (msg))\n\n            if _exit and not index_s:\n                return None\n\n            t.cls()\n\n            try:\n                index = int(index_s) - 1\n                if index < 0:\n                    continue\n                return elements[index]\n            except ValueError: continue\n            except IndexError: continue\n    ')
    
    import main
    
    ################################################################
    # TermGeckoV3 by Iranjin
    # 
    # If you have any questions, please contact the anything thread on the following server:
    # https://discord.gg/YhwRT7cf3B
    # 
    # This program can be rewritten and distributed under the following conditions:
    # * Credit "iranjin#4548"
    # * No self-promotion or selling is allowed.
    #################################################################
