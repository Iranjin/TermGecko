pe_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('main.py', b'\nfrom time import sleep\n\nfrom codes import *\nfrom config import *\nfrom filesys import *\nfrom language import *\nfrom misc import *\nfrom tcp import *\nfrom terminal import *\n\n\nBASE_CONFIG = {\n    "general": {\n        "language": EN,\n        "sleep": 1\n    },\n    "tcpgecko": {\n        "ip_address": None,\n        "timeout": 3,\n        "auto_connect": True\n    },\n    "directory": {\n        "code_file": None\n    }\n}\n\n\ndef main_init():\n    global cfg, tab, term, tcp\n\n    cfg = Config("settings.ini", BASE_CONFIG)\n    tab = Tab()\n    tcp = TCPGecko()\n    term = Terminal()\n\n    if cfg.get("tcpgecko", "ip_address", auto_type = True):\n        tab.Connect()\n    \n\ndef main():\n    main_init()\n\n    language = cfg.get("general", "language")\n\n    tabs = {\n        Language[language]["tab"]["send"]: tab.SendCode,\n        Language[language]["tab"]["disable"]: tab.DisableCode,\n        Language[language]["tab"]["connect"]: tab.Connect,\n        Language[language]["tab"]["code_manager"]: tab.CodeList,\n    }\n\n    title = File("titles")\n    if not title.exists():\n        titles = getFile("https://cdn.discordapp.com/attachments/1116183956233142272/1116183985710710835/titles", str)\n        title.create().overWrite(titles)\n    \n    while True:\n        tcp_status = "%s -> %s" % (\n            Language[language]["tcp_status"],\n            ("%s [%s]" % (Language[language]["main_connected"], tcp.ip_address) if tcp.isConnected() else Language[language]["main_no_connection"]))\n        \n        element = term.elementSelecter(\n            tabs.keys(), "%s\\n\\nTermGecko" % (tcp_status))\n        \n        tabs[element]()\n\n\n\nclass Tab:\n\n    def __init__(self):\n        self.sleep = cfg.get("general", "sleep", float)\n        self.language = cfg.get("general", "language")\n        self.file = None\n        self.connect_count = 0\n\n    \n    def SendCode(self):...\n\n    \n    def DisableCode(self):...\n\n    \n    def Connect(self):\n        def connect(ip_address: str):\n            term.cls()\n            print(Language[self.language]["connecting"])\n            \n            try:\n                tcp.socketInit()\n                tcp.connect(ip_address)\n                \n                cfg.write("tcpgecko", "ip_address", ip_address)\n\n                term.cls()\n\n                print("%s [%s]" % (Language[self.language]["connected"], ip_address))\n                \n                sleep(cfg.get("general", "sleep", float))\n\n                term.cls()\n            except:\n                term.cls()\n                tcp.socketInit()\n                return -1\n            else:\n                return 0\n\n\n        if tcp.isConnected():\n            tcp.disconnect()\n            tcp.socketInit()\n            return\n\n        while True:\n            tcp.setTimeout(cfg.get("tcpgecko", "timeout", float))\n            ip_address = cfg.get("tcpgecko", "ip_address", auto_type = True)\n\n            if not self.connect_count and isIpAddress(ip_address):\n                self.connect_count += 1\n\n                if not cfg.get("tcpgecko", "auto_connect", auto_type = True) and self.connect_count == 1:\n                    return\n\n                if connect(ip_address) == 0:\n                    return\n                \n            term.cls()\n\n            print(Language[self.language]["pls_enter_ip"])\n\n            ip_address = input("%s \\\\ 192.168." % (Language[self.language]["ip_address"]))\n\n            if not ip_address:\n                return\n\n            ip_address = "192.168.%s" % (ip_address)\n\n            term.cls()\n\n            if not isIpAddress(ip_address):\n                continue\n            \n            if connect(ip_address) == 0:\n                return\n    \n\n    def SelectCodeFile(self):\n        term.cls()\n\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n\n        files = []\n\n        for file in os.listdir(current_dir):\n            file = File(file)\n\n            if file.isFile() and file.extention in ["xml", "txt"]:\n                files.append(file.path)\n        \n        element = term.elementSelecter(files, "SelectCodeFile", self.file)\n\n        if not element:\n            return\n\n        self.file = element\n        cfg.write("directory", "code_file", self.file)\n\n    \n    def CodeList(self):\n        term.cls()\n\n        code_file_path = cfg.get("directory", "code_file", auto_type = True)\n\n        if not code_file_path and not self.file:\n            self.SelectCodeFile()\n        else:\n            self.file = code_file_path\n\n        while True:\n                    \n\n            # code_file = File()\n\n\n\n            element_list = ""\n\n            # for element in \n\n            # print("")\n\n            try:\n                input_cmd = input("CodeList \\\\ ")\n                input_cmd_s = input_cmd.split()\n\n                if not input_cmd:\n                    break\n\n                if " " not in input_cmd and isNum(input_cmd):\n                    index = int(input_cmd) - 1\n                \n                elif input_cmd == "c":\n                    self.SelectCodeFile()\n                \n                elif input_cmd in ["c", "change"]:\n                    self.SelectCodeFile()\n                \n                # elif \n\n\n                term.cls()\n            except ValueError:\n                continue\n            except IndexError:\n                continue\n\ntry:\n    main()\nexcept Exception as e:\n    language = Config("settings.ini", BASE_CONFIG).get("general", "language")\n    term = Terminal()\n\n    term.cls()\n    print("Error: \'%s\'\\n%s" % (type(e), Language[language]["error_screenshot"]))\n    sleep(5)\n    term.cls()\n\n    raise e\n')
    __stickytape_write_module('codes.py', b'\nfrom misc import *\nfrom filesys import *\nfrom cstr import *\n\n\nclass CL:\n    \n    def __init__(self, path: str, code_list_space: int = 1, format: bool | None = None):\n        self.__file = File(path)\n        self.__code_list_space = code_list_space\n        self.__format = format\n    \n\n    def parse(self):\n        result = []\n\n        for code in self.__file.read().split("\\n;\\n"):\n            entry = []\n\n            lines = code.strip().splitlines()\n\n            entry.append(lines.pop(0))\n\n            line = lines.pop(0)\n            if line.startswith("@"):\n                entry.append(line\n                               .lstrip("@")\n                               .replace("\\\\n", "\\n"))\n                line = lines.pop(0)\n            else:\n                entry.append(None)\n\n            entry.append((True if line.lower() == "on" else False))\n            entry.append("\\n".join(lines))\n\n            result.append(entry)\n        \n        return result\n    \n\n    def write(self, code_list: list):\n        result = ""\n\n        space = "\\n" * self.__code_list_space\n\n        for i, entry in enumerate(code_list):\n            name, comment, enabled, code = entry\n\n            result += name + "\\n"\n\n            if comment:\n                result += "@" + comment.replace("\\n", "\\\\n") + "\\n"\n\n            result += ("on" if enabled else "off") + "\\n"\n\n            if self.__format is None:\n                result += code + "\\n"\n            elif self.__format:\n                result += cstr(code).formatCode() + "\\n"\n            else:\n                result += cstr(code).stripWhitespace() + "\\n"\n\n            if i != len(code_list) - 1:\n                result += "%s;%s\\n" % (space, space)\n\n        self.__file.overWrite(result.strip())\n    \n\n    def getFile(self):\n        return File(self.__file)\n\n\n    def toXML(self):\n        result = \'<?xml version="1.0" encoding="UTF-16"?><codes>\\n\'\n\n        for entry in self.parse():\n            name, comment, enabled, code = entry\n\n            result += \'    <entry name="%s">\\n\' % (name)\n            result += \'        <code>%s</code>\\n\' % (code)\n            result += \'        <authors/>\\n\'\n            result += \'        <raw_assembly>false</raw_assembly>\\n\'\n            result += \'        <assembly_ram_write>%s</assembly_ram_write>\\n\' % (("true" if cstr(code).isCafeCode() else "false"))\n            result += "        " + (\'<comment>%s</comment>\' % (comment) if comment else "<comment/>") + "\\n"\n            result += \'        <enabled>%s</enabled>\\n\' % (("true" if enabled else "false"))\n            result += \'    </entry>\\n\'\n\n        result += "</codes>"\n        \n        return result\n\n\n\nclass XML:\n    \n    def __init__(self, path: str):\n        self.__file = File(path)\n\n\n    def getFile(self):\n        return File(self.__file)\n\n    \n    def parse(self):\n        result = []\n\n        for entry in self.__parse():\n            _entry = []\n\n            _entry.append(entry["name"])\n            if entry["comment"]:\n                _entry.append(entry["comment"])\n            else:\n                _entry.append(None)\n            _entry.append(entry["enabled"])\n            _entry.append(cstr(entry["code"]).formatCode())\n\n            result.append(_entry)\n        \n        return result\n\n    \n    def __parse(self):\n        result = []\n\n        xml_string = self.__file.read()\n        \n        while len(xml_string) > 0:\n            entry_start = xml_string.find("<entry")\n            if entry_start == -1:\n                break\n            entry_end = xml_string.find("</entry>") + len("</entry>")\n            entry_xml = xml_string[entry_start:entry_end]\n            xml_string = xml_string[entry_end:]\n\n            entry = self.__parse_entry(entry_xml)\n            result.append(entry)\n\n        return result\n    \n\n    def __parse_entry(self, entry_xml: str):\n        result = {}\n\n        name_start = entry_xml.find(\'name="\') + len(\'name="\')\n        name_end = entry_xml.find(\'"\', name_start)\n        result[\'name\'] = entry_xml[name_start:name_end]\n\n        code_start = entry_xml.find("<code>") + len("<code>")\n        code_end = entry_xml.find("</code>")\n        result["code"] = entry_xml[code_start:code_end].strip()\n\n        comment_start = entry_xml.find("<comment>")\n        comment_end = entry_xml.find("</comment>")\n        if comment_start != -1 and comment_end != -1:\n            comment_start += len("<comment>")\n            result["comment"] = entry_xml[comment_start:comment_end].strip()\n        else:\n            result["comment"] = None\n\n        enabled_start = entry_xml.find("<enabled>") + len("<enabled>")\n        enabled_end = entry_xml.find("</enabled>")\n        enable = entry_xml[enabled_start:enabled_end].strip()\n        result["enabled"] = (True if enable == "true" else False)\n\n        return result\n\n\n    def toCL(self, space: int = 1):\n        result = ""\n\n        _space = "\\n" * space\n        xml = self.__parse()\n\n        for i, entry in enumerate(xml):\n            result += entry["name"] + "\\n"\n            result += ("on" if entry["enabled"] else "off") + "\\n"\n            if entry["comment"]:\n                result += "@" + entry["comment"].replace("\\n", "\\\\n") + "\\n"\n            result += entry["code"] + "\\n"\n\n            if i != len(xml) - 1:\n                result += "%s;%s\\n" % (_space, _space)\n        \n        return result.strip()\n')
    __stickytape_write_module('misc.py', b'\nimport re\nimport urllib.request\nimport ssl\nfrom typing import (\n    Any,\n    TypeVar\n)\n\n\nT = TypeVar("T")\n\n\ndef getFile(url: str, obj: type[T] = bytes):\n    ssl._create_default_https_context = ssl._create_unverified_context\n    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"}\n    req = urllib.request.Request(url, headers = headers)\n    response = urllib.request.urlopen(req).read()\n\n    if obj == bytes:\n        return response\n    else:\n        return obj(response.decode("utf-8"))\n\n\ndef isNum(arg: T):\n    try:\n        int(arg)\n    except ValueError:\n        return False\n    else:\n        return True\n\n\ndef digit(num: int):\n    return len(str(num))\n\n\ndef isIpAddress(ip_address: str):\n    try:\n        return re.match(r\'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$\', ip_address) is not None\n    except TypeError:\n        return False\n\n\ndef split(string: str, index: int):\n    result = string.split()\n\n    if index in range(len(result)):\n        return result[index]\n')
    __stickytape_write_module('filesys.py', b'\nimport os\nimport shutil\n\nclass File:\n\n    def __init__(self, path: str):\n        self.__path = path\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\n    def __str__(self):\n        return self.read()\n        \n    \n    @property\n    def extention(self):\n        _, extension = os.path.splitext(self.name)\n        return extension.lstrip(".")\n        \n    \n    @property\n    def name(self):\n        return os.path.basename(self.__path)\n    \n\n    @property\n    def dir(self):\n        return os.path.dirname(self.__path)\n\n\n    @property\n    def path(self):\n        return self.__path\n    \n\n    @property\n    def size(self):\n        return os.path.getsize(self.__path)\n\n\n    def __read_bin(self):\n        with open(self.__path, "rb") as bin:\n            return bin.read()\n    \n\n    def __enc(self, _encoding: str | None):\n        return (_encoding if _encoding else self.encoding())\n    \n\n    def encoding(self):\n        encodings = [\n            \'utf-8\',\n            \'ascii\',\n            \'cp932\',\n            \'shift-jis\'\n        ]\n\n        bytes_text = self.__read_bin()\n\n        for _encoding in encodings:\n            try:\n                bytes_text.decode(_encoding)\n            except UnicodeDecodeError:\n                continue\n            else:\n                return _encoding\n\n        return None\n    \n\n    def setPath(self, path: str) -> \'File\':\n        self.__path = path\n\n        return self\n\n\n    def create(self) -> \'File\':\n        if os.path.exists(self.__path):\n            return self\n        \n        with open(self.__path, "a", encoding = "utf-8") as f:\n            f.write("")\n\n        return self\n\n\n    def getDir(self) -> \'Dir\':\n        return Dir(self.dir)\n\n\n    def write(self, string: str, _encoding: str = None) -> \'File\':\n        self.__write(self.__path, "a", string, self.__enc(_encoding))\n        \n        return self\n    \n\n    def writeBin(self, binary: bytes) -> \'File\':\n        self.__write_bin(self.__path, "ab", binary)\n        \n        return self\n\n\n    def overWrite(self, string: str, _encoding: str = None) -> \'File\':\n        self.__write(self.__path, "w", string, self.__enc(_encoding))\n        \n        return self\n    \n\n    def overWriteBin(self, binary: bytes) -> \'File\':\n        self.__write_bin(self.__path, "wb", binary)\n        \n        return self\n\n\n    def __write(self, path: str, mode: str, string: str, _encoding: str = None):\n        with open(path, mode, encoding = _encoding) as f:\n            f.write(string)\n\n\n    def __write_bin(self, path: str, mode: str, binary: bytes):\n        with open(path, mode) as f:\n            f.write(binary)\n\n\n    def read(self, _encoding: str = None):\n        return self.__read(self.__path, self.__enc(_encoding))\n\n\n    def readBin(self):\n        return self.__read_bin()\n\n\n    def __read(self, path: str, _encoding: str = None):\n        with open(path, "r" , encoding = _encoding) as f:\n            return f.read()\n    \n\n    def rename(self, file_name: str) -> \'File\':\n        directory = os.path.dirname(self.__path)\n        dst = os.path.join(directory, file_name)\n\n        os.rename(self.__path, dst)\n        self.__path = dst\n\n        return self\n\n\n    def delete(self) -> \'File\':\n        os.remove(self.__path)\n\n        return self\n\n    \n    def move(self, path: str) -> \'File\':\n        _path = os.path.join(path, self.name)\n\n        if not os.path.exists(path):\n            os.makedirs(path)\n\n        with open(path, "wb") as bin:\n            bin.write(self.__read_bin())\n        \n        self.delete()\n\n        self.__path = _path\n\n        return self\n\n    \n    def exists(self):\n        return os.path.exists(self.__path)\n    \n\n    def isFile(self):\n        return os.path.isfile(self.__path)\n    \n\n    def isDir(self):\n        return os.path.isdir(self.__path)\n\n    \n    def duplicate(self, _path: str, name: str = None) -> \'File\':\n        path = os.path.join(_path, (name if name else self.name))\n\n        if _path and not os.path.exists(_path):\n            os.makedirs(_path)\n\n        with open(path, "wb") as bin:\n            bin.write(self.__read_bin())\n\n        self.__path = path\n\n        return self\n\n\n\n\nclass Dir:\n\n    def __init__(self, path: str):\n        self.__path = path\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n        \n    \n    @property\n    def name(self):\n        return os.path.basename(self.__path)\n    \n\n    @property\n    def dir(self):\n        return os.path.dirname(self.__path)\n\n\n    @property\n    def path(self):\n        return self.__path\n    \n\n    @property\n    def size(self):\n        return os.path.getsize(self.__path)\n    \n\n    def setPath(self, path: str) -> \'Dir\':\n        self.__path = path\n\n        return self\n\n\n    def create(self) -> \'Dir\':\n        os.makedirs(self.__path, exist_ok = True)\n\n        return self\n\n\n    def delete(self) -> \'Dir\':\n        shutil.rmtree(self.__path)\n\n        return self\n\n    \n    def move(self, path: str) -> \'Dir\':\n        shutil.move(self.__path, path)\n\n        return self\n    \n    \n    def exists(self):\n        return os.path.exists(self.__path)\n    \n\n    def isFile(self):\n        return os.path.isfile(self.__path)\n    \n\n    def isDir(self):\n        return os.path.isdir(self.__path)\n    \n    \n    def dirStats(self):\n        file_cnt = 0\n        dir_cnt = 0\n\n        for _, dir, file in os.walk(self.__path):\n            dir_cnt += len(dir)\n            file_cnt += len(file)\n\n        return file_cnt, dir_cnt\n    \n    \n    def rename(self, file_name: str) -> \'Dir\':\n        directory = os.path.dirname(self.__path)\n        dst = os.path.join(directory, file_name)\n\n        os.rename(self.__path, dst)\n\n        self.__path = dst\n\n        return self\n    \n    \n    def __getDir(self, directory):\n        contents = {}\n        \n        for name in os.listdir(directory):\n            path = os.path.join(directory, name)\n            if os.path.isdir(path):\n                contents[name] = self.__getDir(path)\n            else:\n                contents[name] = File(path).readBin()\n        \n        return contents\n    \n\n    def getDirState(self):\n        if not os.path.isdir(self.__path):\n            raise NotADirectoryError("\'%s\' is not a directory." % (self.__path))\n        \n        return self.__getDir(self.__path)\n    \n\n    def __restoreDirState(self, directory: str, state: dict):\n        for name, data in state.items():\n            path = os.path.join(directory, name)\n\n            if isinstance(data, dict):\n                os.makedirs(path, exist_ok = True)\n                self.__restoreDirState(path, data)\n            else:\n                File(path).overWriteBin(data)\n\n\n    def restoreDirState(self, state: dict) -> \'Dir\':\n        if not self.exists():\n            self.create()\n\n        self.__restoreDirState(self.__path, state)\n\n        return self\n')
    __stickytape_write_module('cstr.py', b'\nclass cstr(str):\n    \n    def stripWhitespace(self) -> \'cstr\':\n        return cstr(self\n                    .replace(" ", "")\n                    .replace("\\n", "")\n                )\n    \n\n    def isCode(self):\n        code = self.stripWhitespace()\n\n        if (len(code) - code.count("#")) % 8:\n            return False\n\n        for x in code:\n            if x.lower() not in [\n                \'a\', \'b\', \'c\', \'d\', \'e\', \'f\',\n                \'0\', \'1\', \'2\', \'3\', \'4\', \'5\',\n                \'6\', \'7\', \'8\', \'9\', \'#\'\n                ]:\n                return False\n        return True\n    \n\n    def isCafeCode(self):\n        code = self.formatCode()\n        \n        for line in code.splitlines():\n            if line.startswith("00020000"): return True\n            elif line.startswith("00120000"): return True\n            elif line.startswith("30000000"): return True\n            elif line.startswith("31000000"): return True\n            elif line.startswith("C0") and line.endswith("60000000"): return True\n            elif line.startswith("30100000") and line.endswith("00000000"): return True\n            elif line.startswith("10000000") and line.endswith("50000000"): return True\n            elif line.startswith("D0000000") and line.endswith("DEADCAFE"): return True\n            \n        return False\n        \n\n    def line(self):\n        if not self:\n            return 0\n        return self.count("\\n") + 1\n\n\n    def isFormatted(self):\n        for _line in self.splitlines():\n            line = _line.lstrip("#")\n\n            if len(line) != 17 or line[8] != " ":\n                return False\n        return True\n    \n\n    def sortLine(self) -> \'cstr\':\n        return cstr("\\n".join(self.splitlines()))\n\n\n    def formatCode(self) -> \'cstr\':\n        code = self.stripWhitespace()\n\n        result = ""\n        \n        i, c = 0, 0\n        while i * 16 + c < len(code):\n            p1 = code[i * 16 + c : i * 16 + 16 + c]\n\n            if p1.startswith("#"):\n                c += 1\n                p2 = code[i * 16 + c : i * 17 + 17]\n                line = p2[:9] + " " + p2[9:]\n            else:\n                line = p1[:8] + " " + p1[8:]\n\n            result += line[:18] + "\\n"\n\n            i += 1\n\n        return cstr(result.rstrip("\\n"))\n\n\n    def getEnableLine(self) -> \'cstr\':\n        result = ""\n\n        for line in self.formatCode().splitlines():\n            if not line.startswith("#"):\n                result += line + "\\n"\n\n        if not self.isFormatted():\n            return cstr(result).stripWhitespace()\n\n        return cstr(result.rstrip("\\n"))\n    \n\n    def getDisableLine(self) -> \'cstr\':\n        result = ""\n\n        for line in self.formatCode().splitlines():\n            if line.startswith("#"):\n                result += line.lstrip("#") + "\\n"\n\n        if not self.isFormatted():\n            return cstr(result).stripWhitespace()\n\n        return cstr(result.rstrip("\\n"))\n    \n\n    def splitRamWrite(self):\n        result = []\n\n        for line in self.formatCode().splitlines():\n            result.append([int(x, 16) for x in line.lstrip("#").split()])\n        \n        return result\n    \n\n    def splitCafeCode(self):\n        result = []\n\n        for line in self.getEnableLine().formatCode().split():\n            result.append(int(line.lstrip("#"), 16))\n        \n        return result\n')
    __stickytape_write_module('config.py', b'\nimport configparser\n\nfrom misc import *\nfrom filesys import *\n\nclass Config:\n    \n    def __init__(\n            self,\n            config_path: str,\n            default: dict = None\n        ):\n        self.__cfgp = configparser.ConfigParser()\n        self.__file = File(config_path)\n        self.__default = default\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\n    def __str__(self):\n        return self.getDict()\n\n    \n    def __read(self):\n        if not self.__file.exists():\n            self.__file.create()\n\n        self.__cfgp.read(\n            self.__file.path,\n            encoding = self.__file.encoding()\n        )\n\n        \n    def getFile(self):\n        return File(self.__file)\n\n    \n    def writeDict(self, dict_config: dict, over_write: bool = False):\n        self.__read()\n\n        if over_write:\n            self.__cfgp.clear()\n\n        for section, options in dict_config.items():\n            self.__cfgp[section] = options\n\n        with open(self.__file.path, "w", encoding = self.__file.encoding()) as file:\n            self.__cfgp.write(file)\n        \n        return self\n\n\n    def write(self, section: str, option: str, write_data: str):\n        data = self.getDict()\n\n        if section not in data:\n            data[section] = {}\n        \n        data[section][option] = write_data\n        \n        self.writeDict(data)\n\n        return self\n\n    \n    def getDict(self):\n        self.__read()\n        \n        data = {}\n        for section in self.__cfgp.sections():\n            data[section] = dict(self.__cfgp.items(section))\n        \n        return data\n    \n\n    def get(self, section: str, option: str, obj: type[T] = str, auto_type: bool = False):\n        origin = self.getDict()\n\n        if self.__default and (not self.hasSection(section) or not self.hasOption(section, option)):\n            write_data = origin\n\n            if section not in write_data:\n                write_data[section] = {}\n\n            write_data[section][option] = str(self.__default[section][option])\n            self.writeDict(write_data)\n\n        try:\n            result = origin[section][option]\n            if auto_type:\n                if result == "None":\n                    return None\n                elif result == "True":\n                    return True\n                elif result == "False":\n                    return False\n                elif isNum(result):\n                    return int(result)\n            return obj(result)\n        except KeyError:\n            return None\n    \n\n    def removeSection(self, section: str):\n        if self.hasSection(section):\n            self.__cfgp.remove_section(section)\n\n        return self\n    \n\n    def removeOption(self, option: str):\n        if self.hasOption(option):\n            self.__cfgp.remove_option(option)\n\n        return self\n\n\n    def hasSection(self, section: str):\n        return self.__cfgp.has_section(section)\n    \n    \n    def hasOption(self, section: str, option: str):\n        return self.__cfgp.has_option(section, option)\n')
    __stickytape_write_module('language.py', b'\nEN = "en"\nJA = "ja"\n\nLanguage = {\n    "en": {\n        "help": "Help",\n        "send_code": "Send",\n        "disable_code": "Disable",\n        "pls_enter_ip": "Please enter your WiiU IPAddress",\n        "ip_address": "IP Address",\n        "connecting": "Connecting...",\n        "connected": "Connected",\n        "main_connected": "Connected",\n        "main_no_connection": "NoConnection",\n        "disconnected": "Disconnected",\n        "error_screenshot": "An error has occurred. The error message will be displayed in 5 seconds. Please send a screenshot to iranjin#4548.",\n        "tcp_status": "TCPStatus",\n        "tab": {\n            "send": "Send",\n            "disable": "Disable",\n            "connect": "Connect/Disconnect",\n            "code_manager": "CodeManager",\n        },\n    },\n    "ja": {\n        "help": "\xe3\x83\x98\xe3\x83\xab\xe3\x83\x97",\n        "send_code": "\xe9\x80\x81\xe4\xbf\xa1",\n        "disable_code": "\xe8\xa7\xa3\xe9\x99\xa4",\n        "pls_enter_ip": "WiiU\xe3\x81\xaeIP\xe3\x82\xa2\xe3\x83\x89\xe3\x83\xac\xe3\x82\xb9\xe3\x82\x92\xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84",\n        "ip_address": "IP\xe3\x82\xa2\xe3\x83\x89\xe3\x83\xac\xe3\x82\xb9",\n        "connecting": "\xe6\x8e\xa5\xe7\xb6\x9a\xe4\xb8\xad...",\n        "connected": "\xe6\x8e\xa5\xe7\xb6\x9a\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f",\n        "main_connected": "\xe6\x8e\xa5\xe7\xb6\x9a\xe6\xb8\x88\xe3\x81\xbf",\n        "main_no_connection": "\xe9\x9d\x9e\xe6\x8e\xa5\xe7\xb6\x9a",\n        "disconnected": "\xe5\x88\x87\xe6\x96\xad\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f",\n        "error_screenshot": "\xe3\x82\xa8\xe3\x83\xa9\xe3\x83\xbc\xe3\x81\x8c\xe7\x99\xba\xe7\x94\x9f\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f\xe3\x80\x82\xe3\x82\xa8\xe3\x83\xa9\xe3\x83\xbc\xe3\x83\xa1\xe3\x83\x83\xe3\x82\xbb\xe3\x83\xbc\xe3\x82\xb8\xe3\x81\x8c5\xe7\xa7\x92\xe5\xbe\x8c\xe3\x81\xab\xe8\xa1\xa8\xe7\xa4\xba\xe3\x81\x95\xe3\x82\x8c\xe3\x81\xbe\xe3\x81\x99\xe3\x80\x82\xe3\x82\xb9\xe3\x82\xaf\xe3\x83\xaa\xe3\x83\xbc\xe3\x83\xb3\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x82\x92iranjin#4548\xe3\x81\xab\xe9\x80\x81\xe4\xbf\xa1\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84\xe3\x80\x82",\n        "tcp_status": "TCP\xe3\x82\xb9\xe3\x83\x86\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xb9",\n        "tab": {\n            "send": "\xe9\x80\x81\xe4\xbf\xa1",\n            "disable": "\xe8\xa7\xa3\xe9\x99\xa4",\n            "connect": "\xe6\x8e\xa5\xe7\xb6\x9a/\xe5\x88\x87\xe6\x96\xad",\n            "code_manager": "\xe3\x82\xb3\xe3\x83\xbc\xe3\x83\x89\xe3\x83\x9e\xe3\x83\x8d\xe3\x83\xbc\xe3\x82\xb8\xe3\x83\xa3\xe3\x83\xbc",\n        },\n    }\n}\n')
    __stickytape_write_module('tcp.py', b'\nimport socket\nimport struct\nimport re\n\nfrom enum import Enum\nfrom cstr import *\n\nclass CMD(Enum):\n    POKE_8                      = b\'\\x01\'\n    POKE_16                     = b\'\\x02\'\n    POKE_32                     = b\'\\x03\'\n    READ_MEMORY                 = b\'\\x04\'\n    READ_MEMORY_KERNEL          = b\'\\x05\'\n    VALIDATE_ADDRESS_RANGE      = b\'\\x06\'\n    MEMORY_DISASSEMBLE          = b\'\\x08\'\n    # READ_MEMORY_COMPRESSED    = b\'\\x09\'\n    KERNEL_WRITE                = b\'\\x0B\' \n    KERNEL_READ                 = b\'\\x0C\'\n    # TAKE_SCREENSHOT            = b\'\\x0D\'\n    UPLOAD_MEMORY               = b\'\\x41\'\n    SERVER_STATUS               = b\'\\x50\'\n    GET_DATA_BUFFER_SIZE        = b\'\\x51\'\n    READ_FILE                   = b\'\\x52\'\n    READ_DIRECTORY              = b\'\\x53\'\n    REPLACE_FILE                = b\'\\x54\'\n    GET_CODE_HANDLER_ADDRESS    = b\'\\x55\'\n    READ_THREADS                = b\'\\x56\'\n    ACCOUNT_IDENTIFIER          = b\'\\x57\'\n    # WRITE_SCREEN              = b\'\\x58\'\n    FOLLOW_POINTER              = b\'\\x60\'\n    REMOTE_PROCEDURE_CALL       = b\'\\x70\'\n    GET_SYMBOL                  = b\'\\x71\'\n    MEMORY_SEARCH               = b\'\\x72\'\n    ADVANCED_MEMORY_SEARCH      = b\'\\x73\'\n    EXECUTE_ASSEMBLY            = b\'\\x81\'\n    PAUSE_CONSOLE               = b\'\\x82\'\n    RESUME_CONSOLE              = b\'\\x83\'\n    IS_CONSOLE_PAUSED           = b\'\\x84\'\n    GET_SERVER_VERSION          = b\'\\x99\'\n    GET_OS_VERSION              = b\'\\x9A\'\n    SET_DATA_BREAKPOINT         = b\'\\xA0\'\n    SET_INSTRUCTION_BREAKPOINT  = b\'\\xA2\'\n    TOGGLE_BREAKPOINT           = b\'\\xA5\'\n    REMOVE_ALL_BREAKPOINT       = b\'\\xA6\'\n    POKE_REGISTERS              = b\'\\xA7\'\n    GET_STACK_TRACE             = b\'\\xA8\'\n    GET_ENTRY_POINT_ADDRESS     = b\'\\xB1\'\n    RUN_KERNEL_COPY_SERVICE     = b\'\\xCD\'\n    IOSU_HAX_READ_FILE          = b\'\\xD0\'\n    GET_VERSION_HASH            = b\'\\xE0\'\n    PERSIST_ASSEMBLY            = b\'\\xE1\'\n    CLEAR_ASSEMBLY              = b\'\\xE2\'\n\n\n\nclass TCPGecko:\n\n    def __init__(self, ip_address: str = None, port: int = 7331, clear_cafe: bool = False):\n        self.__timeout = 5.0\n        self.__connected = False\n        self.__ip_address = None\n        self.__port = port\n        self.clear_cafe = clear_cafe\n        if ip_address:\n            self.setIpAddress(ip_address)\n        self.socketInit()\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.__connected:\n            self.disconnect()\n    \n    \n    def socketInit(self):\n        self.__connected = False\n        self.__s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        return self\n\n\n    def setTimeout(self, timeout: float):\n        self.__timeout = timeout\n\n        return self\n    \n\n    def setIpAddress(self, ip_address: str, port: int = 7331):\n        if re.match(r\'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$\', ip_address) is None:\n            raise ValueError("Invalid ip address format \'%s\'" % (ip_address))\n        self.__ip_address = ip_address\n        self.__port = port\n\n        return self\n\n\n    @property\n    def ip_address(self):\n        return self.__ip_address\n    \n\n    def connect(self, ip_address: str = None, port: int = None, timeout: float = None):\n        if self.__connected:\n            return self\n        \n        self.__s.settimeout((timeout if timeout else self.__timeout))\n\n        try:\n            self.__s.connect((\n                (ip_address if ip_address else self.__ip_address),\n                ((port if port else self.__port))))\n        except TimeoutError as e:\n            self.__connected = False\n            raise e\n        else:\n            self.__ip_address = ip_address\n            self.__connected = True\n\n        return self\n\n\n    def disconnect(self):\n        self.__connected = False\n\n        if not self.__connected:\n            return self\n\n        self.__s.close()\n\n        return self\n    \n\n    def isConnected(self):\n        return self.__connected\n    \n\n    def getTitleId(self):...\n\n\n    def poke(\n            self,\n            address: int,\n            value: int,\n            size: int = 32\n        ):\n\n        if   size == 8:  cmd = CMD.POKE_8\n        elif size == 16: cmd = CMD.POKE_16\n        elif size == 32: cmd = CMD.POKE_32\n        else:\n            raise ValueError("Invalid int value size: %d" % (size))\n\n        self.__s.send(cmd)\n        self.__s.send(struct.pack("\\\\II", address, value))\n\n        return self\n\n    \n    def assemblyRamWrite(self, _asm_code: cstr | str):\n        asm_code = cstr(_asm_code.replace("#", ""))\n\n        if not (asm_code or asm_code.isCode()):\n            raise ValueError("The code is invalid: %s" % (asm_code))\n        \n        code = asm_code.formatCode().splitRamWrite()\n\n        for line in code:\n            self.poke(line[0], line[1])\n        \n        return self\n    \n    \n    def sendCafeCode(self, _cafe_code: cstr | str):\n        cafe_code = cstr(_cafe_code.replace("#", ""))\n\n        if not (cafe_code or cafe_code.isCode()):\n            raise ValueError("The code is invalid: %s" % (cafe_code))\n        \n        code = cafe_code.formatCode().splitCafeCode()\n        code.append(0x0)\n\n        self.switchCafeCode(False)\n\n        for i, value in enumerate(code):\n            self.poke(0x01133000 + i * 4, value)\n\n        self.switchCafeCode(True)\n\n        return self\n    \n\n    def switchCafeCode(self, switch: bool):\n        self.poke(0x10014CFC, (0x1 if switch else 0x0))\n\n        return self\n    \n\n    def disableCafeCode(self):\n        self.switchCafeCode(False)\n        if self.clear_cafe:\n            self.__clearCafeCode()\n\n        return self\n\n\n    def __clearCafeCode(self, _range: int = 2656):\n        for i in range(_range):\n            self.poke(0x01133000 + i * 4, 0x0)\n')
    __stickytape_write_module('terminal.py', b'\nimport platform\nimport os\n\nfrom misc import *\n\nclass Terminal:\n    \n    def __init__(self, line: int = 99):\n        self.__clear_command = None\n        self.__line = line\n\n        self.__getClearCmd()\n    \n\n    def __getClearCmd(self):\n        sys = platform.system()\n        pf = platform.platform()\n\n        if "iOS" in pf:\n            self.__clear_command = None\n            return None\n        \n        if sys == "Windows":\n            self.__clear_command = "cls"\n            return "Windows"\n        elif sys == "Darwin":\n            self.__clear_command = "clear"\n            return "macos"\n        elif sys == "Linux":\n            self.__clear_command = "clear"\n            return "linux"\n        else:\n            self.__clear_command = None\n            return None\n        \n\n    def cls(self):\n        if not self.__clear_command:\n            print("\\n" * self.__line)\n            return\n        os.system(self.__clear_command)\n\n\n    @staticmethod\n    def elementSelecter(_list: list, msg: str, _exit: bool = False):\n        _list = list(_list)\n\n        if not _list:\n            return None\n\n        t = Terminal()\n\n        while True:\n            t.cls()\n\n            for i, element in enumerate(_list):\n                print("%s \xe2\x94\x82 %s" % (\n                        str(i + 1).rjust(digit(len(_list))), element))\n            \n            index_s = input("%s \\\\ " % (msg))\n\n            if _exit and not index_s:\n                return None\n\n            t.cls()\n\n            try:\n                index = int(index_s) - 1\n                return _list[index]\n            except ValueError: continue\n            except IndexError: continue\n    ')
    
    import main
    
    ################################################################
    # TermGeckoV3 by Iranjin
    # 
    # If you have any questions, please contact the anything thread on the following server:
    # https://discord.gg/YhwRT7cf3B
    # 
    # This program can be rewritten and distributed under the following conditions:
    # * Credit "iranjin#4548"
    # * No self-promotion or selling is allowed.
    #################################################################
