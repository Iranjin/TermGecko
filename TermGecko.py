# beta 1.2

#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('main.py', b'\nfrom time import sleep\nimport re\n\nfrom codes import *\nfrom config import *\nfrom filesys import *\nfrom language import *\nfrom misc import *\nfrom tcp import *\nfrom terminal import *\n\n\ndef main_init():\n    global BASE_CONFIG, cfg, tab, term, tcp\n\n    BASE_CONFIG = {\n        "general": {\n            "language": EN,\n            "sleep": 1\n        },\n        "tcpgecko": {\n            "ip_address": None,\n            "timeout": 3,\n            "auto_connect": True\n        },\n        "directory": {\n            "code_file": None\n        }\n    }\n\n    cfg = Config("settings.ini", BASE_CONFIG)\n    tab = Tab()\n    tcp = TCPGecko()\n    term = Terminal()\n\n    if cfg.get("tcpgecko", "ip_address", auto_type = True):\n        tab.Connect()\n    \n\ndef main():\n    main_init()\n\n    language = cfg.get("general", "language")\n    lang_tab = Language[language]["tab"]\n\n    tabs = {\n        lang_tab["send"]: tab.SendCode,\n        lang_tab["disable"]: tab.DisableCode,\n        lang_tab["connect"]: tab.Connect,\n        lang_tab["code_manager"]: tab.CodeList,\n    }\n\n    # with File(".titles") as title:\n    #     if not title.exists():\n    #         titles = getFile("https://raw.githubusercontent.com/Iranjin/TermGecko/main/titles", str)\n    #         title.create().overWrite(titles)\n    \n    while True:\n        tcp_status = "%s -> %s" % (\n            Language[language]["tcp_status"],\n            ("%s [%s]" % (Language[language]["main_connected"], tcp.ip_address) if tcp.isConnected() else Language[language]["main_no_connection"]))\n        \n        element = term.elementSelecter(\n            tabs.keys(), "%s\\n\\nTermGecko" % (tcp_status))\n        \n        tabs[element]()\n\n\n\nclass Tab:\n\n    def __init__(self):\n        self.sleep = cfg.get("general", "sleep", float)\n        self.language = cfg.get("general", "language")\n        self.file_path = None\n        self.connect_count = 0\n        self.codes = None\n        self.code_file = None\n    \n\n    def __send(self, enable_mode: bool):\n        term.cls()\n\n        if not tcp.isConnected():\n            return\n\n        code_file_path = cfg.get("directory", "code_file", auto_type = True)\n\n        if not code_file_path and not self.file_path:\n            print(Language[self.language]["file_not_selected"])\n\n            sleep(self.sleep)\n\n            self.SelectCodeFile()\n        else:\n            self.file_path = code_file_path\n            self.UpdateCodes()\n        \n        codes = self.code_file.parse()\n        \n        enable_codes = []\n        enable_code_names = []\n\n        for entry in codes:\n            if entry[2]:\n                code = cstr(entry[3])\n                enable_codes.append(code)\n                if not code.isCafeCode() and not code.getDisableLine():\n                    continue\n                enable_code_names.append(entry[0])\n\n        print("\\n".join(enable_code_names))\n\n\n        for code in enable_codes:\n            code = cstr(code)\n            \n            if enable_mode:\n                if code.isCafeCode():\n                    tcp.sendCafeCode(code.getEnableLine())\n                else:\n                    tcp.assemblyRamWrite(code.getEnableLine())\n            else:\n                tcp.assemblyRamWrite(code.getDisableLine())\n        \n        if not enable_mode:\n            tcp.disableCafeCode()\n        \n        sleep(self.sleep)\n\n    \n    def SendCode(self):\n        self.__send(True)\n\n    \n    def DisableCode(self):\n        self.__send(False)\n        \n    \n    def Connect(self):\n        def connect(ip_address: str):\n            term.cls()\n            print(Language[self.language]["connecting"])\n            \n            try:\n                tcp.socketInit()\n                tcp.connect(ip_address)\n                \n                cfg.write("tcpgecko", "ip_address", ip_address)\n\n                term.cls()\n\n                print("%s [%s]" % (Language[self.language]["connected"], ip_address))\n                \n                sleep(cfg.get("general", "sleep", float))\n\n                term.cls()\n            except:\n                term.cls()\n                tcp.socketInit()\n                return -1\n            else:\n                return 0\n\n\n        if tcp.isConnected():\n            tcp.disconnect()\n            tcp.socketInit()\n            return\n\n        while True:\n            tcp.setTimeout(cfg.get("tcpgecko", "timeout", float))\n            ip_address = cfg.get("tcpgecko", "ip_address", auto_type = True)\n\n            if not self.connect_count and isIpAddress(ip_address):\n                self.connect_count += 1\n\n                if not cfg.get("tcpgecko", "auto_connect", auto_type = True) and self.connect_count == 1:\n                    return\n\n                if connect(ip_address) == 0:\n                    return\n                \n            term.cls()\n\n            print(Language[self.language]["pls_enter_ip"])\n\n            ip_address = input("%s \\\\ 192.168." % (Language[self.language]["ip_address"]))\n\n            if not ip_address:\n                return\n\n            ip_address = "192.168.%s" % (ip_address)\n\n            term.cls()\n\n            if not isIpAddress(ip_address):\n                continue\n            \n            if connect(ip_address) == 0:\n                return\n    \n\n    def SelectCodeFile(self):\n        term.cls()\n\n        files = []\n\n        for file in os.listdir(Dir.getCurrentDir()):\n            file = File(file)\n\n            if file.isFile() and file.extention in ["xml", "txt"]:\n                files.append(file.path)\n        \n        element = term.elementSelecter(files, "SelectCodeFile", self.file_path)\n\n        if not element:\n            return False\n\n        self.file_path = element\n        cfg.write("directory", "code_file", self.file_path)\n\n        self.UpdateCodes()\n\n        term.cls()\n\n        return True\n    \n\n    def UpdateCodes(self):\n        term.cls()\n\n        print(Language[self.language]["loading"])\n\n        extention = File(self.file_path).extention\n        if extention == "txt":\n            self.code_file = CL(self.file_path)\n        else:\n            self.code_file = XML(self.file_path)\n\n        if not File(self.file_path).exists():\n            cfg.write("directory", "code_file", None)\n            result = self.SelectCodeFile()\n            if not result:\n                self.UpdateCodes()\n\n        self.codes = self.code_file.parse()[::-1]\n\n        term.cls()\n\n    \n    def CodeList(self):\n        term.cls()\n\n        code_file_path = cfg.get("directory", "code_file", auto_type = True)\n\n        if not code_file_path and not self.file_path:\n            self.SelectCodeFile()\n        else:\n            self.file_path = code_file_path\n            self.UpdateCodes()\n\n        while True:\n            if not self.codes:\n                return\n\n            code_list = ["%s\xe2\x94\x82%s\xe2\x94\x82%s" %\n                (str(i + 1).ljust(len(str(len(self.codes)))), ("\xe2\x96\xa0" if x[2] else " "), x[0])\n                for i, x in enumerate(self.codes)][::-1]\n            print("\\n".join(code_list))\n\n            try:\n                input_cmd = input("CodeList \\\\ ")\n                input_cmd_s = input_cmd.split()\n\n                if not input_cmd:\n                    term.cls()\n                    print(Language[self.language]["saving"])\n                    self.code_file.write(self.codes[::-1])\n                    term.cls()\n                    break\n\n                if len(input_cmd_s) == 1 and isNum(input_cmd):\n                    index = int(input_cmd) - 1\n                    self.codes[index][2] = not self.codes[index][2]\n\n                elif len(input_cmd_s) > 1 and isNum(input_cmd_s):\n                    for x in input_cmd_s:\n                        index = int(x) - 1\n                        self.codes[index][2] = not self.codes[index][2]\n\n                elif re.match(r\'[0-9]*?![0-9]*?\', input_cmd):\n                    index1, index2 = sorted(re.findall(r\'[0-9]*?![0-9]*?\', input_cmd)[0])\n                    for i in range(int(index1) - 1, int(index2)):\n                        self.codes[i][2] = not self.codes[i][2]\n                \n                elif input_cmd == "c":\n                    self.SelectCodeFile()\n                \n\n                elif input_cmd == ".off":\n                    for i in range(len(self.codes)):\n                        self.codes[i][2] = False\n                \n\n                elif input_cmd == ".on":\n                    for i in range(len(self.codes)):\n                        self.codes[i][2] = True\n                    \n\n                term.cls()\n            except ValueError:\n                continue\n            except IndexError:\n                continue\n\ntry:\n    main()\nexcept Exception as e:\n    language = Config("settings.ini", BASE_CONFIG).get("general", "language")\n    term = Terminal()\n\n    term.cls()\n    print("Error: \'%s\'\\n%s" % (type(e), Language[language]["error_screenshot"]))\n    sleep(5)\n    term.cls()\n\n    raise e\n')
    __stickytape_write_module('codes.py', b'\nfrom misc import *\nfrom filesys import *\nfrom cstr import *\n\n\nclass CL:\n    \n    def __init__(self, path: str, code_list_space: int = 1, format: bool = None):\n        self.__file = File(path)\n        self.__code_list_space = code_list_space\n        self.__format = format\n    \n\n    def getFile(self):\n        return File(self.__file)\n    \n\n    def parse(self):\n        result = []\n\n        for code in self.__file.read().split("\\n;\\n"):\n            entry = []\n\n            lines = code.strip().splitlines()\n\n            entry.append(lines.pop(0))\n\n            line = lines.pop(0)\n            if line.startswith("@"):\n                entry.append(line\n                               .lstrip("@")\n                               .replace("\\\\n", "\\n"))\n                line = lines.pop(0)\n            else:\n                entry.append(None)\n\n            entry.append((True if line.lower() == "on" else False))\n            entry.append("\\n".join(lines))\n\n            result.append(entry)\n        \n        return result\n    \n\n    def write(self, code_list: list):\n        result = ""\n\n        space = "\\n" * self.__code_list_space\n\n        for i, entry in enumerate(code_list):\n            name, comment, enabled, code = entry\n\n            result += name + "\\n"\n\n            if comment:\n                result += "@" + comment.replace("\\n", "\\\\n") + "\\n"\n\n            result += ("on" if enabled else "off") + "\\n"\n\n            if self.__format is None:\n                result += code + "\\n"\n            elif self.__format:\n                result += cstr(code).formatCode() + "\\n"\n            else:\n                result += cstr(code).stripWhitespace() + "\\n"\n\n            if i != len(code_list) - 1:\n                result += "%s;%s\\n" % (space, space)\n\n        self.__file.overWrite(result.strip())\n\n\n    def toXML(self):\n        result = \'<?xml version="1.0" encoding="UTF-16"?><codes>\\n\'\n\n        for entry in self.parse():\n            name, comment, enabled, code = entry\n\n            result += \'    <entry name="%s">\\n\' % (name)\n            result += \'        <code>%s</code>\\n\' % (code)\n            result += \'        <authors/>\\n\'\n            result += \'        <raw_assembly>false</raw_assembly>\\n\'\n            result += \'        <assembly_ram_write>%s</assembly_ram_write>\\n\' % (("true" if cstr(code).isCafeCode() else "false"))\n            result += "        " + (\'<comment>%s</comment>\' % (comment) if comment else "<comment/>") + "\\n"\n            result += \'        <enabled>%s</enabled>\\n\' % (("true" if enabled else "false"))\n            result += \'    </entry>\\n\'\n\n        result += "</codes>"\n        \n        return result\n\n\n\nclass XML:\n    \n    def __init__(self, path: str):\n        self.__file = File(path)\n\n\n    def getFile(self):\n        return self.__file\n\n    \n    def parse(self):\n        result = []\n\n        for entry in self.__parse():\n            _entry = []\n\n            _entry.append(entry["name"])\n            if entry["comment"]:\n                _entry.append(entry["comment"])\n            else:\n                _entry.append(None)\n            _entry.append(entry["enabled"])\n            _entry.append(cstr(entry["code"]).formatCode())\n\n            result.append(_entry)\n        \n        return result\n\n    \n    def __parse(self):\n        result = []\n\n        xml_string = self.__file.read()\n        \n        while len(xml_string) > 0:\n            entry_start = xml_string.find("<entry")\n            if entry_start == -1:\n                break\n            entry_end = xml_string.find("</entry>") + len("</entry>")\n            entry_xml = xml_string[entry_start:entry_end]\n            xml_string = xml_string[entry_end:]\n\n            entry = self.__parse_entry(entry_xml)\n            result.append(entry)\n\n        return result\n    \n\n    def __parse_entry(self, entry_xml: str):\n        result = {}\n\n        name_start = entry_xml.find("name=\\"") + len("name=\\"")\n        name_end = entry_xml.find("\\"", name_start)\n        result["name"] = entry_xml[name_start:name_end]\n\n        code_start = entry_xml.find("<code>") + len("<code>")\n        code_end = entry_xml.find("</code>")\n        result["code"] = entry_xml[code_start:code_end].strip()\n\n        comment_start = entry_xml.find("<comment>")\n        comment_end = entry_xml.find("</comment>")\n        if comment_start != -1 and comment_end != -1:\n            comment_start += len("<comment>")\n            result["comment"] = entry_xml[comment_start:comment_end].strip()\n        else:\n            result["comment"] = None\n\n        enabled_start = entry_xml.find("<enabled>") + len("<enabled>")\n        enabled_end = entry_xml.find("</enabled>")\n        enable = entry_xml[enabled_start:enabled_end].strip()\n        result["enabled"] = (True if enable == "true" else False)\n\n        return result\n\n\n    def toCL(self, space: int = 1):\n        result = ""\n\n        _space = "\\n" * space\n        xml = self.__parse()\n\n        for i, entry in enumerate(xml):\n            result += entry["name"] + "\\n"\n            result += ("on" if entry["enabled"] else "off") + "\\n"\n            if entry["comment"]:\n                result += "@" + entry["comment"].replace("\\n", "\\\\n") + "\\n"\n            result += entry["code"] + "\\n"\n\n            if i != len(xml) - 1:\n                result += "%s;%s\\n" % (_space, _space)\n        \n        return result.strip()\n\n    \n    def write(self, xml_string: str):\n        result = "<?xml version=\\"1.0\\" encoding=\\"UTF-16\\"?><codes>\\n"\n\n        for entry in xml_string:\n            name, comment, enabled, code = entry\n\n            result += "    <entry name\\"%s\\">\\n" % (name)\n            result += "        <code>%s</code>\\n" % (code)\n            result += "        <authors/>\\n"\n            result += "        <raw_assembly>false</raw_assembly>\\n"\n            result += "        <assembly_ram_write>%s</assembly_ram_write>\\n" % (("true" if cstr(code).isCafeCode() else "false"))\n            result += "        " + ("<comment>%s</comment>" % (comment) if comment else "<comment/>") + "\\n"\n            result += "        <enabled>%s</enabled>\\n" % (("true" if enabled else "false"))\n            result += "    </entry>\\n"\n\n        result += "</codes>"\n        \n        self.__file.write(result)')
    __stickytape_write_module('misc.py', b'\nimport re\nimport urllib.request\nimport ssl\nfrom typing import TypeVar\n\n\nT = TypeVar("T")\n\n\ndef getFile(url: str, obj: type[T] = bytes):\n    ssl._create_default_https_context = ssl._create_unverified_context\n    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"}\n    req = urllib.request.Request(url, headers = headers)\n    response = urllib.request.urlopen(req).read()\n\n    if obj == bytes:\n        return response\n    else:\n        return obj(response.decode("utf-8"))\n\n\ndef isNum(arg: T):\n    if type(arg) == list:\n        if not arg:\n            return False\n        for x in arg:\n            try:\n                int(x)\n            except ValueError:\n                return False\n        return True\n\n    try:\n        int(arg)\n    except ValueError:\n        return False\n    else:\n        return True\n\n\ndef digit(num: int):\n    return len(str(num))\n\n\ndef isIpAddress(ip_address: str):\n    try:\n        return re.match(r\'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$\', ip_address) is not None\n    except TypeError:\n        return False\n\n\ndef split(string: str, index: int):\n    result = string.split()\n\n    if index in range(len(result)):\n        return result[index]\n')
    __stickytape_write_module('filesys.py', b'\nimport os\nimport shutil\n\nclass File:\n\n    def __init__(self, path: str):\n        self.__path = path\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\n    def __str__(self):\n        return self.read()\n        \n    \n    @property\n    def extention(self):\n        _, extension = os.path.splitext(self.name)\n        return extension.lstrip(".")\n        \n    \n    @property\n    def name(self):\n        return os.path.basename(self.__path)\n    \n\n    @property\n    def dir(self):\n        return os.path.dirname(self.__path)\n\n\n    @property\n    def path(self):\n        return self.__path\n    \n\n    @property\n    def size(self):\n        return os.path.getsize(self.__path)\n\n\n    def __read_bin(self):\n        with open(self.__path, "rb") as bin:\n            return bin.read()\n    \n\n    def __enc(self, _encoding: str):\n        return (_encoding if _encoding else self.encoding())\n    \n\n    def encoding(self):\n        encodings = [\n            \'utf-8\',\n            \'ascii\',\n            \'cp932\',\n            \'shift-jis\'\n        ]\n\n        bytes_text = self.__read_bin()\n\n        for encoding in encodings:\n            try:\n                bytes_text.decode(encoding)\n            except UnicodeDecodeError:\n                continue\n            else:\n                return encoding\n\n        return None\n    \n\n    def setPath(self, path: str):\n        self.__path = path\n\n        return self\n\n\n    def create(self):\n        if os.path.exists(self.__path):\n            return self\n        \n        with open(self.__path, "a", encoding = "utf-8") as f:\n            f.write("")\n\n        return self\n\n\n    def getDir(self):\n        return Dir(self.dir)\n\n\n    def write(self, string: str, _encoding: str = None):\n        self.__write(self.__path, "a", string, self.__enc(_encoding))\n        \n        return self\n    \n\n    def writeBin(self, binary: bytes):\n        self.__write_bin(self.__path, "ab", binary)\n        \n        return self\n\n\n    def overWrite(self, string: str, _encoding: str = None):\n        self.__write(self.__path, "w", string, self.__enc(_encoding))\n        \n        return self\n    \n\n    def overWriteBin(self, binary: bytes):\n        self.__write_bin(self.__path, "wb", binary)\n        \n        return self\n\n\n    def __write(self, path: str, mode: str, string: str, _encoding: str = None):\n        with open(path, mode, encoding = _encoding) as f:\n            f.write(string)\n\n\n    def __write_bin(self, path: str, mode: str, binary: bytes):\n        with open(path, mode) as f:\n            f.write(binary)\n\n\n    def read(self, _encoding: str = None):\n        return self.__read(self.__path, self.__enc(_encoding))\n\n\n    def readBin(self):\n        return self.__read_bin()\n\n\n    def __read(self, path: str, _encoding: str = None):\n        with open(path, "r" , encoding = _encoding) as f:\n            return f.read()\n    \n\n    def rename(self, file_name: str):\n        directory = os.path.dirname(self.__path)\n        dst = os.path.join(directory, file_name)\n\n        os.rename(self.__path, dst)\n        self.__path = dst\n\n        return self\n\n\n    def delete(self):\n        os.remove(self.__path)\n\n        return self\n\n    \n    def move(self, path: str):\n        _path = os.path.join(path, self.name)\n\n        if not os.path.exists(path):\n            os.makedirs(path)\n\n        with open(path, "wb") as bin:\n            bin.write(self.__read_bin())\n        \n        self.delete()\n\n        self.__path = _path\n\n        return self\n\n    \n    def exists(self):\n        return os.path.exists(self.__path)\n    \n\n    def isFile(self):\n        return os.path.isfile(self.__path)\n    \n\n    def isDir(self):\n        return os.path.isdir(self.__path)\n\n    \n    def duplicate(self, _path: str, name: str = None):\n        path = os.path.join(_path, (name if name else self.name))\n\n        if _path and not os.path.exists(_path):\n            os.makedirs(_path)\n\n        with open(path, "wb") as bin:\n            bin.write(self.__read_bin())\n\n        self.__path = path\n\n        return self\n\n\n\n\nclass Dir:\n\n    def __init__(self, path: str):\n        self.__path = path\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n        \n    \n    @property\n    def name(self):\n        return os.path.basename(self.__path)\n    \n\n    @property\n    def dir(self):\n        return os.path.dirname(self.__path)\n\n\n    @property\n    def path(self):\n        return self.__path\n    \n\n    @property\n    def size(self):\n        return os.path.getsize(self.__path)\n    \n\n    @staticmethod\n    def getCurrentDir():\n        return os.path.dirname(os.path.abspath(__file__))\n    \n\n    def setPath(self, path: str):\n        self.__path = path\n\n        return self\n\n\n    def create(self):\n        os.makedirs(self.__path, exist_ok = True)\n\n        return self\n\n\n    def delete(self):\n        shutil.rmtree(self.__path)\n\n        return self\n\n    \n    def move(self, path: str):\n        shutil.move(self.__path, path)\n\n        return self\n    \n    \n    def exists(self):\n        return os.path.exists(self.__path)\n    \n\n    def isFile(self):\n        return os.path.isfile(self.__path)\n    \n\n    def isDir(self):\n        return os.path.isdir(self.__path)\n    \n    \n    def dirStats(self):\n        file_cnt = 0\n        dir_cnt = 0\n\n        for _, dir, file in os.walk(self.__path):\n            dir_cnt += len(dir)\n            file_cnt += len(file)\n\n        return file_cnt, dir_cnt\n    \n    \n    def rename(self, file_name: str):\n        directory = os.path.dirname(self.__path)\n        dst = os.path.join(directory, file_name)\n\n        os.rename(self.__path, dst)\n\n        self.__path = dst\n\n        return self\n    \n    \n    def __getDir(self, directory):\n        contents = {}\n        \n        for name in os.listdir(directory):\n            path = os.path.join(directory, name)\n            if os.path.isdir(path):\n                contents[name] = self.__getDir(path)\n            else:\n                contents[name] = File(path).readBin()\n        \n        return contents\n    \n\n    def getDirState(self):\n        if not os.path.isdir(self.__path):\n            raise NotADirectoryError("\'%s\' is not a directory." % (self.__path))\n        \n        return self.__getDir(self.__path)\n    \n\n    def __restoreDirState(self, directory: str, state: dict):\n        for name, data in state.items():\n            path = os.path.join(directory, name)\n\n            if isinstance(data, dict):\n                os.makedirs(path, exist_ok = True)\n                self.__restoreDirState(path, data)\n            else:\n                File(path).overWriteBin(data)\n\n\n    def restoreDirState(self, state: dict):\n        if not self.exists():\n            self.create()\n\n        self.__restoreDirState(self.__path, state)\n\n        return self\n')
    __stickytape_write_module('cstr.py', b'\nclass cstr(str):\n    \n    def stripWhitespace(self) -> \'cstr\':\n        return cstr(self\n                    .replace(" ", "")\n                    .replace("\\n", "")\n                )\n    \n\n    def isCode(self):\n        code = self.stripWhitespace()\n\n        if (len(code) - code.count("#")) % 8:\n            return False\n\n        for x in code:\n            if x.lower() not in [\n                \'a\', \'b\', \'c\', \'d\', \'e\', \'f\',\n                \'0\', \'1\', \'2\', \'3\', \'4\', \'5\',\n                \'6\', \'7\', \'8\', \'9\', \'#\'\n                ]:\n                return False\n        return True\n    \n\n    def isCafeCode(self):\n        code = self.formatCode()\n        \n        for line in code.splitlines():\n            if line.startswith("00020000"): return True\n            elif line.startswith("00120000"): return True\n            elif line.startswith("30000000"): return True\n            elif line.startswith("31000000"): return True\n            elif line.startswith("C0") and line.endswith("60000000"): return True\n            elif line.startswith("30100000") and line.endswith("00000000"): return True\n            elif line.startswith("10000000") and line.endswith("50000000"): return True\n            elif line.startswith("D0000000") and line.endswith("DEADCAFE"): return True\n            \n        return False\n        \n\n    def line(self):\n        if not self:\n            return 0\n        return self.count("\\n") + 1\n\n\n    def isFormatted(self):\n        for line in self.splitlines():\n            line = line.lstrip("#")\n\n            if len(line) != 17 or line[8] != " ":\n                return False\n        return True\n    \n\n    def sortLine(self) -> \'cstr\':\n        return cstr("\\n".join(self.splitlines()))\n\n\n    def formatCode(self) -> \'cstr\':\n        code = self.stripWhitespace()\n\n        result = ""\n        \n        i, c = 0, 0\n        while i * 16 + c < len(code):\n            p1 = code[i * 16 + c : i * 16 + 16 + c]\n            p2 = code[i * 16 + c : i * 17 + 17]\n\n            if p1.startswith("#"):\n                c += 1\n                line = p2[:9] + " " + p2[9:]\n            else:\n                line = p1[:8] + " " + p1[8:]\n\n            result += line[:18] + "\\n"\n\n            i += 1\n\n        return cstr(result.rstrip("\\n"))\n\n\n    def getEnableLine(self) -> \'cstr\':\n        result = ""\n\n        for line in self.formatCode().splitlines():\n            if not line.startswith("#"):\n                result += line + "\\n"\n\n        if not self.isFormatted():\n            return cstr(result).stripWhitespace()\n\n        return cstr(result.rstrip("\\n"))\n    \n\n    def getDisableLine(self) -> \'cstr\':\n        result = ""\n\n        for line in self.formatCode().splitlines():\n            if line.startswith("#"):\n                result += line.lstrip("#") + "\\n"\n\n        if not self.isFormatted():\n            return cstr(result).stripWhitespace()\n\n        return cstr(result.rstrip("\\n"))\n    \n\n    def splitRamWrite(self):\n        result = []\n\n        for line in self.formatCode().splitlines():\n            result.append([int(x, 16) for x in line.lstrip("#").split()])\n        \n        return result\n    \n\n    def splitCafeCode(self):\n        result = []\n\n        for line in self.getEnableLine().formatCode().split():\n            result.append(int(line.lstrip("#"), 16))\n        \n        return result\n')
    __stickytape_write_module('config.py', b'\nimport configparser_copy as configparser\n\nfrom misc import *\nfrom filesys import *\n\nclass Config:\n    \n    def __init__(\n            self,\n            config_path: str,\n            default: dict = None\n        ):\n        self.__cfgp = configparser.ConfigParser()\n        self.__file = File(config_path)\n        self.__default = default\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\n    def __str__(self):\n        return self.getDict()\n\n    \n    def __read(self):\n        if not self.__file.exists():\n            self.__file.create()\n\n        self.__cfgp.read(\n            self.__file.path,\n            encoding = self.__file.encoding()\n        )\n\n        \n    def getFile(self):\n        return File(self.__file)\n\n    \n    def writeDict(self, dict_config: dict, over_write: bool = False):\n        self.__read()\n\n        if over_write:\n            self.__cfgp.clear()\n\n        for section, options in dict_config.items():\n            self.__cfgp[section] = options\n\n        with open(self.__file.path, "w", encoding = self.__file.encoding()) as file:\n            self.__cfgp.write(file)\n        \n        return self\n\n\n    def write(self, section: str, option: str, write_data: str):\n        data = self.getDict()\n\n        if section not in data:\n            data[section] = {}\n        \n        data[section][option] = str(write_data)\n        \n        self.writeDict(data)\n\n        return self\n\n    \n    def getDict(self):\n        self.__read()\n        \n        data = {}\n        for section in self.__cfgp.sections():\n            data[section] = dict(self.__cfgp.items(section))\n        \n        return data\n    \n\n    def get(self, section: str, option: str, obj: type[T] = str, auto_type: bool = False):\n        origin = self.getDict()\n\n        if self.__default and (not self.hasSection(section) or not self.hasOption(section, option)):\n            write_data = origin\n\n            if section not in write_data:\n                write_data[section] = {}\n\n            write_data[section][option] = str(self.__default[section][option])\n            self.writeDict(write_data)\n\n        try:\n            result = origin[section][option]\n            if auto_type:\n                if result == "None":\n                    return None\n                elif result == "True":\n                    return True\n                elif result == "False":\n                    return False\n                elif isNum(result):\n                    return int(result)\n            return obj(result)\n        except KeyError:\n            return None\n    \n\n    def removeSection(self, section: str):\n        if self.hasSection(section):\n            self.__cfgp.remove_section(section)\n\n        return self\n    \n\n    def removeOption(self, option: str):\n        if self.hasOption(option):\n            self.__cfgp.remove_option(option)\n\n        return self\n\n\n    def hasSection(self, section: str):\n        return self.__cfgp.has_section(section)\n    \n    \n    def hasOption(self, section: str, option: str):\n        return self.__cfgp.has_option(section, option)\n')
    __stickytape_write_module('configparser_copy.py', b'\nfrom collections.abc import MutableMapping\nfrom collections import ChainMap as _ChainMap\nimport functools\nimport io\nimport itertools\nimport os\nimport re\nimport sys\nimport warnings\n\n__all__ = ["NoSectionError", "DuplicateOptionError", "DuplicateSectionError",\n           "NoOptionError", "InterpolationError", "InterpolationDepthError",\n           "InterpolationMissingOptionError", "InterpolationSyntaxError",\n           "ParsingError", "MissingSectionHeaderError",\n           "ConfigParser", "SafeConfigParser", "RawConfigParser",\n           "Interpolation", "BasicInterpolation",  "ExtendedInterpolation",\n           "LegacyInterpolation", "SectionProxy", "ConverterMapping",\n           "DEFAULTSECT", "MAX_INTERPOLATION_DEPTH"]\n\n_default_dict = dict\nDEFAULTSECT = "DEFAULT"\n\nMAX_INTERPOLATION_DEPTH = 10\n\n\n\n# exception classes\nclass Error(Exception):\n    \n    def __init__(self, msg=\'\'):\n        self.message = msg\n        Exception.__init__(self, msg)\n\n    def __repr__(self):\n        return self.message\n\n    __str__ = __repr__\n\n\nclass NoSectionError(Error):\n\n    def __init__(self, section):\n        Error.__init__(self, \'No section: %r\' % (section,))\n        self.section = section\n        self.args = (section, )\n\n\nclass DuplicateSectionError(Error):\n\n    def __init__(self, section, source=None, lineno=None):\n        msg = [repr(section), " already exists"]\n        if source is not None:\n            message = ["While reading from ", repr(source)]\n            if lineno is not None:\n                message.append(" [line {0:2d}]".format(lineno))\n            message.append(": section ")\n            message.extend(msg)\n            msg = message\n        else:\n            msg.insert(0, "Section ")\n        Error.__init__(self, "".join(msg))\n        self.section = section\n        self.source = source\n        self.lineno = lineno\n        self.args = (section, source, lineno)\n\n\nclass DuplicateOptionError(Error):\n\n    def __init__(self, section, option, source=None, lineno=None):\n        msg = [repr(option), " in section ", repr(section),\n               " already exists"]\n        if source is not None:\n            message = ["While reading from ", repr(source)]\n            if lineno is not None:\n                message.append(" [line {0:2d}]".format(lineno))\n            message.append(": option ")\n            message.extend(msg)\n            msg = message\n        else:\n            msg.insert(0, "Option ")\n        Error.__init__(self, "".join(msg))\n        self.section = section\n        self.option = option\n        self.source = source\n        self.lineno = lineno\n        self.args = (section, option, source, lineno)\n\n\nclass NoOptionError(Error):\n\n    def __init__(self, option, section):\n        Error.__init__(self, "No option %r in section: %r" %\n                       (option, section))\n        self.option = option\n        self.section = section\n        self.args = (option, section)\n\n\nclass InterpolationError(Error):\n\n    def __init__(self, option, section, msg):\n        Error.__init__(self, msg)\n        self.option = option\n        self.section = section\n        self.args = (option, section, msg)\n\n\nclass InterpolationMissingOptionError(InterpolationError):\n\n    def __init__(self, option, section, rawval, reference):\n        msg = ("Bad value substitution: option {!r} in section {!r} contains "\n               "an interpolation key {!r} which is not a valid option name. "\n               "Raw value: {!r}".format(option, section, reference, rawval))\n        InterpolationError.__init__(self, option, section, msg)\n        self.reference = reference\n        self.args = (option, section, rawval, reference)\n\n\nclass InterpolationSyntaxError(InterpolationError):\n    pass\n\n\nclass InterpolationDepthError(InterpolationError):\n\n    def __init__(self, option, section, rawval):\n        msg = ("Recursion limit exceeded in value substitution: option {!r} "\n               "in section {!r} contains an interpolation key which "\n               "cannot be substituted in {} steps. Raw value: {!r}"\n               "".format(option, section, MAX_INTERPOLATION_DEPTH,\n                         rawval))\n        InterpolationError.__init__(self, option, section, msg)\n        self.args = (option, section, rawval)\n\n\nclass ParsingError(Error):\n\n    def __init__(self, source=None, filename=None):\n        if filename and source:\n            raise ValueError("Cannot specify both `filename\' and `source\'. "\n                             "Use `source\'.")\n        elif not filename and not source:\n            raise ValueError("Required argument `source\' not given.")\n        elif filename:\n            source = filename\n        Error.__init__(self, \'Source contains parsing errors: %r\' % source)\n        self.source = source\n        self.errors = []\n        self.args = (source, )\n\n    @property\n    def filename(self):\n        warnings.warn(\n            "The \'filename\' attribute will be removed in Python 3.12. "\n            "Use \'source\' instead.",\n            DeprecationWarning, stacklevel=2\n        )\n        return self.source\n\n    @filename.setter\n    def filename(self, value):\n        warnings.warn(\n            "The \'filename\' attribute will be removed in Python 3.12. "\n            "Use \'source\' instead.",\n            DeprecationWarning, stacklevel=2\n        )\n        self.source = value\n\n    def append(self, lineno, line):\n        self.errors.append((lineno, line))\n        self.message += \'\\n\\t[line %2d]: %s\' % (lineno, line)\n\n\nclass MissingSectionHeaderError(ParsingError):\n\n    def __init__(self, filename, lineno, line):\n        Error.__init__(\n            self,\n            \'File contains no section headers.\\nfile: %r, line: %d\\n%r\' %\n            (filename, lineno, line))\n        self.source = filename\n        self.lineno = lineno\n        self.line = line\n        self.args = (filename, lineno, line)\n\n\n_UNSET = object()\n\n\nclass Interpolation:\n\n    def before_get(self, parser, section, option, value, defaults):\n        return value\n\n    def before_set(self, parser, section, option, value):\n        return value\n\n    def before_read(self, parser, section, option, value):\n        return value\n\n    def before_write(self, parser, section, option, value):\n        return value\n\n\nclass BasicInterpolation(Interpolation):\n\n    _KEYCRE = re.compile(r"%\\(([^)]+)\\)s")\n\n    def before_get(self, parser, section, option, value, defaults):\n        L = []\n        self._interpolate_some(parser, option, L, value, section, defaults, 1)\n        return \'\'.join(L)\n\n    def before_set(self, parser, section, option, value):\n        tmp_value = value.replace(\'%%\', \'\') # escaped percent signs\n        tmp_value = self._KEYCRE.sub(\'\', tmp_value) # valid syntax\n        if \'%\' in tmp_value:\n            raise ValueError("invalid interpolation syntax in %r at "\n                             "position %d" % (value, tmp_value.find(\'%\')))\n        return value\n\n    def _interpolate_some(self, parser, option, accum, rest, section, map,\n                          depth):\n        rawval = parser.get(section, option, raw=True, fallback=rest)\n        if depth > MAX_INTERPOLATION_DEPTH:\n            raise InterpolationDepthError(option, section, rawval)\n        while rest:\n            p = rest.find("%")\n            if p < 0:\n                accum.append(rest)\n                return\n            if p > 0:\n                accum.append(rest[:p])\n                rest = rest[p:]\n            # p is no longer used\n            c = rest[1:2]\n            if c == "%":\n                accum.append("%")\n                rest = rest[2:]\n            elif c == "(":\n                m = self._KEYCRE.match(rest)\n                if m is None:\n                    raise InterpolationSyntaxError(option, section,\n                        "bad interpolation variable reference %r" % rest)\n                var = parser.optionxform(m.group(1))\n                rest = rest[m.end():]\n                try:\n                    v = map[var]\n                except KeyError:\n                    raise InterpolationMissingOptionError(\n                        option, section, rawval, var) from None\n                if "%" in v:\n                    self._interpolate_some(parser, option, accum, v,\n                                           section, map, depth + 1)\n                else:\n                    accum.append(v)\n            else:\n                raise InterpolationSyntaxError(\n                    option, section,\n                    "\'%%\' must be followed by \'%%\' or \'(\', "\n                    "found: %r" % (rest,))\n\n\nclass ExtendedInterpolation(Interpolation):\n\n    _KEYCRE = re.compile(r"\\$\\{([^}]+)\\}")\n\n    def before_get(self, parser, section, option, value, defaults):\n        L = []\n        self._interpolate_some(parser, option, L, value, section, defaults, 1)\n        return \'\'.join(L)\n\n    def before_set(self, parser, section, option, value):\n        tmp_value = value.replace(\'$$\', \'\') # escaped dollar signs\n        tmp_value = self._KEYCRE.sub(\'\', tmp_value) # valid syntax\n        if \'$\' in tmp_value:\n            raise ValueError("invalid interpolation syntax in %r at "\n                             "position %d" % (value, tmp_value.find(\'$\')))\n        return value\n\n    def _interpolate_some(self, parser, option, accum, rest, section, map,\n                          depth):\n        rawval = parser.get(section, option, raw=True, fallback=rest)\n        if depth > MAX_INTERPOLATION_DEPTH:\n            raise InterpolationDepthError(option, section, rawval)\n        while rest:\n            p = rest.find("$")\n            if p < 0:\n                accum.append(rest)\n                return\n            if p > 0:\n                accum.append(rest[:p])\n                rest = rest[p:]\n            # p is no longer used\n            c = rest[1:2]\n            if c == "$":\n                accum.append("$")\n                rest = rest[2:]\n            elif c == "{":\n                m = self._KEYCRE.match(rest)\n                if m is None:\n                    raise InterpolationSyntaxError(option, section,\n                        "bad interpolation variable reference %r" % rest)\n                path = m.group(1).split(\':\')\n                rest = rest[m.end():]\n                sect = section\n                opt = option\n                try:\n                    if len(path) == 1:\n                        opt = parser.optionxform(path[0])\n                        v = map[opt]\n                    elif len(path) == 2:\n                        sect = path[0]\n                        opt = parser.optionxform(path[1])\n                        v = parser.get(sect, opt, raw=True)\n                    else:\n                        raise InterpolationSyntaxError(\n                            option, section,\n                            "More than one \':\' found: %r" % (rest,))\n                except (KeyError, NoSectionError, NoOptionError):\n                    raise InterpolationMissingOptionError(\n                        option, section, rawval, ":".join(path)) from None\n                if "$" in v:\n                    self._interpolate_some(parser, opt, accum, v, sect,\n                                           dict(parser.items(sect, raw=True)),\n                                           depth + 1)\n                else:\n                    accum.append(v)\n            else:\n                raise InterpolationSyntaxError(\n                    option, section,\n                    "\'$\' must be followed by \'$\' or \'{\', "\n                    "found: %r" % (rest,))\n\n\nclass LegacyInterpolation(Interpolation):\n\n    _KEYCRE = re.compile(r"%\\(([^)]*)\\)s|.")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            "LegacyInterpolation has been deprecated since Python 3.2 "\n            "and will be removed from the configparser module in Python 3.13. "\n            "Use BasicInterpolation or ExtendedInterpolation instead.",\n            DeprecationWarning, stacklevel=2\n        )\n\n    def before_get(self, parser, section, option, value, vars):\n        rawval = value\n        depth = MAX_INTERPOLATION_DEPTH\n        while depth:                    # Loop through this until it\'s done\n            depth -= 1\n            if value and "%(" in value:\n                replace = functools.partial(self._interpolation_replace,\n                                            parser=parser)\n                value = self._KEYCRE.sub(replace, value)\n                try:\n                    value = value % vars\n                except KeyError as e:\n                    raise InterpolationMissingOptionError(\n                        option, section, rawval, e.args[0]) from None\n            else:\n                break\n        if value and "%(" in value:\n            raise InterpolationDepthError(option, section, rawval)\n        return value\n\n    def before_set(self, parser, section, option, value):\n        return value\n\n    @staticmethod\n    def _interpolation_replace(match, parser):\n        s = match.group(1)\n        if s is None:\n            return match.group()\n        else:\n            return "%%(%s)s" % parser.optionxform(s)\n\n\nclass RawConfigParser(MutableMapping):\n\n    _SECT_TMPL = r"""\n        \\[                                 # [\n        (?P<header>.+)                     # very permissive!\n        \\]                                 # ]\n        """\n    _OPT_TMPL = r"""\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?P<vi>{delim})\\s*              # any number of space/tab,\n                                           # followed by any of the\n                                           # allowed delimiters,\n                                           # followed by any space/tab\n        (?P<value>.*)$                     # everything up to eol\n        """\n    _OPT_NV_TMPL = r"""\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?:                             # any number of space/tab,\n        (?P<vi>{delim})\\s*                 # optionally followed by\n                                           # any of the allowed\n                                           # delimiters, followed by any\n                                           # space/tab\n        (?P<value>.*))?$                   # everything up to eol\n        """\n    _DEFAULT_INTERPOLATION = Interpolation()\n    SECTCRE = re.compile(_SECT_TMPL, re.VERBOSE)\n    OPTCRE = re.compile(_OPT_TMPL.format(delim="=|:"), re.VERBOSE)\n    OPTCRE_NV = re.compile(_OPT_NV_TMPL.format(delim="=|:"), re.VERBOSE)\n    NONSPACECRE = re.compile(r"\\S")\n    BOOLEAN_STATES = {\'1\': True, \'yes\': True, \'true\': True, \'on\': True,\n                      \'0\': False, \'no\': False, \'false\': False, \'off\': False}\n\n    def __init__(self, defaults=None, dict_type=_default_dict,\n                 allow_no_value=False, *, delimiters=(\'=\', \':\'),\n                 comment_prefixes=(\'#\', \';\'), inline_comment_prefixes=None,\n                 strict=True, empty_lines_in_values=True,\n                 default_section=DEFAULTSECT,\n                 interpolation=_UNSET, converters=_UNSET):\n\n        self._dict = dict_type\n        self._sections = self._dict()\n        self._defaults = self._dict()\n        self._converters = ConverterMapping(self)\n        self._proxies = self._dict()\n        self._proxies[default_section] = SectionProxy(self, default_section)\n        self._delimiters = tuple(delimiters)\n        if delimiters == (\'=\', \':\'):\n            self._optcre = self.OPTCRE_NV if allow_no_value else self.OPTCRE\n        else:\n            d = "|".join(re.escape(d) for d in delimiters)\n            if allow_no_value:\n                self._optcre = re.compile(self._OPT_NV_TMPL.format(delim=d),\n                                          re.VERBOSE)\n            else:\n                self._optcre = re.compile(self._OPT_TMPL.format(delim=d),\n                                          re.VERBOSE)\n        self._comment_prefixes = tuple(comment_prefixes or ())\n        self._inline_comment_prefixes = tuple(inline_comment_prefixes or ())\n        self._strict = strict\n        self._allow_no_value = allow_no_value\n        self._empty_lines_in_values = empty_lines_in_values\n        self.default_section=default_section\n        self._interpolation = interpolation\n        if self._interpolation is _UNSET:\n            self._interpolation = self._DEFAULT_INTERPOLATION\n        if self._interpolation is None:\n            self._interpolation = Interpolation()\n        if not isinstance(self._interpolation, Interpolation):\n            raise TypeError(\n                f"interpolation= must be None or an instance of Interpolation;"\n                f" got an object of type {type(self._interpolation)}"\n            )\n        if converters is not _UNSET:\n            self._converters.update(converters)\n        if defaults:\n            self._read_defaults(defaults)\n\n    def defaults(self):\n        return self._defaults\n\n    def sections(self):\n        return list(self._sections.keys())\n\n    def add_section(self, section):\n        if section == self.default_section:\n            raise ValueError(\'Invalid section name: %r\' % section)\n\n        if section in self._sections:\n            raise DuplicateSectionError(section)\n        self._sections[section] = self._dict()\n        self._proxies[section] = SectionProxy(self, section)\n\n    def has_section(self, section):\n        return section in self._sections\n\n    def options(self, section):\n        try:\n            opts = self._sections[section].copy()\n        except KeyError:\n            raise NoSectionError(section) from None\n        opts.update(self._defaults)\n        return list(opts.keys())\n\n    def read(self, filenames, encoding=None):\n        if isinstance(filenames, (str, bytes, os.PathLike)):\n            filenames = [filenames]\n        encoding = io.text_encoding(encoding)\n        read_ok = []\n        for filename in filenames:\n            try:\n                with open(filename, encoding=encoding) as fp:\n                    self._read(fp, filename)\n            except OSError:\n                continue\n            if isinstance(filename, os.PathLike):\n                filename = os.fspath(filename)\n            read_ok.append(filename)\n        return read_ok\n\n    def read_file(self, f, source=None):\n        if source is None:\n            try:\n                source = f.name\n            except AttributeError:\n                source = \'<???>\'\n        self._read(f, source)\n\n    def read_string(self, string, source=\'<string>\'):\n        sfile = io.StringIO(string)\n        self.read_file(sfile, source)\n\n    def read_dict(self, dictionary, source=\'<dict>\'):\n        elements_added = set()\n        for section, keys in dictionary.items():\n            section = str(section)\n            try:\n                self.add_section(section)\n            except (DuplicateSectionError, ValueError):\n                if self._strict and section in elements_added:\n                    raise\n            elements_added.add(section)\n            for key, value in keys.items():\n                key = self.optionxform(str(key))\n                if value is not None:\n                    value = str(value)\n                if self._strict and (section, key) in elements_added:\n                    raise DuplicateOptionError(section, key, source)\n                elements_added.add((section, key))\n                self.set(section, key, value)\n\n    def readfp(self, fp, filename=None):\n        warnings.warn(\n            "This method will be removed in Python 3.12. "\n            "Use \'parser.read_file()\' instead.",\n            DeprecationWarning, stacklevel=2\n        )\n        self.read_file(fp, source=filename)\n\n    def get(self, section, option, *, raw=False, vars=None, fallback=_UNSET):\n        try:\n            d = self._unify_values(section, vars)\n        except NoSectionError:\n            if fallback is _UNSET:\n                raise\n            else:\n                return fallback\n        option = self.optionxform(option)\n        try:\n            value = d[option]\n        except KeyError:\n            if fallback is _UNSET:\n                raise NoOptionError(option, section)\n            else:\n                return fallback\n\n        if raw or value is None:\n            return value\n        else:\n            return self._interpolation.before_get(self, section, option, value,\n                                                  d)\n\n    def _get(self, section, conv, option, **kwargs):\n        return conv(self.get(section, option, **kwargs))\n\n    def _get_conv(self, section, option, conv, *, raw=False, vars=None,\n                  fallback=_UNSET, **kwargs):\n        try:\n            return self._get(section, conv, option, raw=raw, vars=vars,\n                             **kwargs)\n        except (NoSectionError, NoOptionError):\n            if fallback is _UNSET:\n                raise\n            return fallback\n\n    def getint(self, section, option, *, raw=False, vars=None,\n               fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, int, raw=raw, vars=vars,\n                              fallback=fallback, **kwargs)\n\n    def getfloat(self, section, option, *, raw=False, vars=None,\n                 fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, float, raw=raw, vars=vars,\n                              fallback=fallback, **kwargs)\n\n    def getboolean(self, section, option, *, raw=False, vars=None,\n                   fallback=_UNSET, **kwargs):\n        return self._get_conv(section, option, self._convert_to_boolean,\n                              raw=raw, vars=vars, fallback=fallback, **kwargs)\n\n    def items(self, section=_UNSET, raw=False, vars=None):\n        if section is _UNSET:\n            return super().items()\n        d = self._defaults.copy()\n        try:\n            d.update(self._sections[section])\n        except KeyError:\n            if section != self.default_section:\n                raise NoSectionError(section)\n        orig_keys = list(d.keys())\n        if vars:\n            for key, value in vars.items():\n                d[self.optionxform(key)] = value\n        value_getter = lambda option: self._interpolation.before_get(self,\n            section, option, d[option], d)\n        if raw:\n            value_getter = lambda option: d[option]\n        return [(option, value_getter(option)) for option in orig_keys]\n\n    def popitem(self):\n        for key in self.sections():\n            value = self[key]\n            del self[key]\n            return key, value\n        raise KeyError\n\n    def optionxform(self, optionstr):\n        return optionstr.lower()\n\n    def has_option(self, section, option):\n        if not section or section == self.default_section:\n            option = self.optionxform(option)\n            return option in self._defaults\n        elif section not in self._sections:\n            return False\n        else:\n            option = self.optionxform(option)\n            return (option in self._sections[section]\n                    or option in self._defaults)\n\n    def set(self, section, option, value=None):\n        if value:\n            value = self._interpolation.before_set(self, section, option,\n                                                   value)\n        if not section or section == self.default_section:\n            sectdict = self._defaults\n        else:\n            try:\n                sectdict = self._sections[section]\n            except KeyError:\n                raise NoSectionError(section) from None\n        sectdict[self.optionxform(option)] = value\n\n    def write(self, fp, space_around_delimiters=True):\n        if space_around_delimiters:\n            d = " {} ".format(self._delimiters[0])\n        else:\n            d = self._delimiters[0]\n        if self._defaults:\n            self._write_section(fp, self.default_section,\n                                    self._defaults.items(), d)\n        for section in self._sections:\n            self._write_section(fp, section,\n                                self._sections[section].items(), d)\n\n    def _write_section(self, fp, section_name, section_items, delimiter):\n        fp.write("[{}]\\n".format(section_name))\n        for key, value in section_items:\n            value = self._interpolation.before_write(self, section_name, key,\n                                                     value)\n            if value is not None or not self._allow_no_value:\n                value = delimiter + str(value).replace(\'\\n\', \'\\n\\t\')\n            else:\n                value = ""\n            fp.write("{}{}\\n".format(key, value))\n        fp.write("\\n")\n\n    def remove_option(self, section, option):\n        if not section or section == self.default_section:\n            sectdict = self._defaults\n        else:\n            try:\n                sectdict = self._sections[section]\n            except KeyError:\n                raise NoSectionError(section) from None\n        option = self.optionxform(option)\n        existed = option in sectdict\n        if existed:\n            del sectdict[option]\n        return existed\n\n    def remove_section(self, section):\n        existed = section in self._sections\n        if existed:\n            del self._sections[section]\n            del self._proxies[section]\n        return existed\n\n    def __getitem__(self, key):\n        if key != self.default_section and not self.has_section(key):\n            raise KeyError(key)\n        return self._proxies[key]\n\n    def __setitem__(self, key, value):\n        if key in self and self[key] is value:\n            return\n        if key == self.default_section:\n            self._defaults.clear()\n        elif key in self._sections:\n            self._sections[key].clear()\n        self.read_dict({key: value})\n\n    def __delitem__(self, key):\n        if key == self.default_section:\n            raise ValueError("Cannot remove the default section.")\n        if not self.has_section(key):\n            raise KeyError(key)\n        self.remove_section(key)\n\n    def __contains__(self, key):\n        return key == self.default_section or self.has_section(key)\n\n    def __len__(self):\n        return len(self._sections) + 1\n\n    def __iter__(self):\n        return itertools.chain((self.default_section,), self._sections.keys())\n\n    def _read(self, fp, fpname):\n        elements_added = set()\n        cursect = None\n        sectname = None\n        optname = None\n        lineno = 0\n        indent_level = 0\n        e = None\n        for lineno, line in enumerate(fp, start=1):\n            comment_start = sys.maxsize\n            # strip inline comments\n            inline_prefixes = {p: -1 for p in self._inline_comment_prefixes}\n            while comment_start == sys.maxsize and inline_prefixes:\n                next_prefixes = {}\n                for prefix, index in inline_prefixes.items():\n                    index = line.find(prefix, index+1)\n                    if index == -1:\n                        continue\n                    next_prefixes[prefix] = index\n                    if index == 0 or (index > 0 and line[index-1].isspace()):\n                        comment_start = min(comment_start, index)\n                inline_prefixes = next_prefixes\n            # strip full line comments\n            for prefix in self._comment_prefixes:\n                if line.strip().startswith(prefix):\n                    comment_start = 0\n                    break\n            if comment_start == sys.maxsize:\n                comment_start = None\n            value = line[:comment_start].strip()\n            if not value:\n                if self._empty_lines_in_values:\n                    # add empty line to the value, but only if there was no\n                    # comment on the line\n                    if (comment_start is None and\n                        cursect is not None and\n                        optname and\n                        cursect[optname] is not None):\n                        cursect[optname].append(\'\') # newlines added at join\n                else:\n                    # empty line marks end of value\n                    indent_level = sys.maxsize\n                continue\n            # continuation line?\n            first_nonspace = self.NONSPACECRE.search(line)\n            cur_indent_level = first_nonspace.start() if first_nonspace else 0\n            if (cursect is not None and optname and\n                cur_indent_level > indent_level):\n                cursect[optname].append(value)\n            # a section header or option header?\n            else:\n                indent_level = cur_indent_level\n                # is it a section header?\n                mo = self.SECTCRE.match(value)\n                if mo:\n                    sectname = mo.group(\'header\')\n                    if sectname in self._sections:\n                        if self._strict and sectname in elements_added:\n                            raise DuplicateSectionError(sectname, fpname,\n                                                        lineno)\n                        cursect = self._sections[sectname]\n                        elements_added.add(sectname)\n                    elif sectname == self.default_section:\n                        cursect = self._defaults\n                    else:\n                        cursect = self._dict()\n                        self._sections[sectname] = cursect\n                        self._proxies[sectname] = SectionProxy(self, sectname)\n                        elements_added.add(sectname)\n                    # So sections can\'t start with a continuation line\n                    optname = None\n                # no section header in the file?\n                elif cursect is None:\n                    raise MissingSectionHeaderError(fpname, lineno, line)\n                # an option line?\n                else:\n                    mo = self._optcre.match(value)\n                    if mo:\n                        optname, vi, optval = mo.group(\'option\', \'vi\', \'value\')\n                        if not optname:\n                            e = self._handle_error(e, fpname, lineno, line)\n                        optname = self.optionxform(optname.rstrip())\n                        if (self._strict and\n                            (sectname, optname) in elements_added):\n                            raise DuplicateOptionError(sectname, optname,\n                                                       fpname, lineno)\n                        elements_added.add((sectname, optname))\n                        # This check is fine because the OPTCRE cannot\n                        # match if it would set optval to None\n                        if optval is not None:\n                            optval = optval.strip()\n                            cursect[optname] = [optval]\n                        else:\n                            # valueless option handling\n                            cursect[optname] = None\n                    else:\n                        e = self._handle_error(e, fpname, lineno, line)\n        self._join_multiline_values()\n        # if any parsing errors occurred, raise an exception\n        if e:\n            raise e\n\n    def _join_multiline_values(self):\n        defaults = self.default_section, self._defaults\n        all_sections = itertools.chain((defaults,),\n                                       self._sections.items())\n        for section, options in all_sections:\n            for name, val in options.items():\n                if isinstance(val, list):\n                    val = \'\\n\'.join(val).rstrip()\n                options[name] = self._interpolation.before_read(self,\n                                                                section,\n                                                                name, val)\n\n    def _read_defaults(self, defaults):\n        for key, value in defaults.items():\n            self._defaults[self.optionxform(key)] = value\n\n    def _handle_error(self, exc, fpname, lineno, line):\n        if not exc:\n            exc = ParsingError(fpname)\n        exc.append(lineno, repr(line))\n        return exc\n\n    def _unify_values(self, section, vars):\n        sectiondict = {}\n        try:\n            sectiondict = self._sections[section]\n        except KeyError:\n            if section != self.default_section:\n                raise NoSectionError(section) from None\n        # Update with the entry specific variables\n        vardict = {}\n        if vars:\n            for key, value in vars.items():\n                if value is not None:\n                    value = str(value)\n                vardict[self.optionxform(key)] = value\n        return _ChainMap(vardict, sectiondict, self._defaults)\n\n    def _convert_to_boolean(self, value):\n        if value.lower() not in self.BOOLEAN_STATES:\n            raise ValueError(\'Not a boolean: %s\' % value)\n        return self.BOOLEAN_STATES[value.lower()]\n\n    def _validate_value_types(self, *, section="", option="", value=""):\n        if not isinstance(section, str):\n            raise TypeError("section names must be strings")\n        if not isinstance(option, str):\n            raise TypeError("option keys must be strings")\n        if not self._allow_no_value or value:\n            if not isinstance(value, str):\n                raise TypeError("option values must be strings")\n\n    @property\n    def converters(self):\n        return self._converters\n\n\nclass ConfigParser(RawConfigParser):\n\n    _DEFAULT_INTERPOLATION = BasicInterpolation()\n\n    def set(self, section, option, value=None):\n        self._validate_value_types(option=option, value=value)\n        super().set(section, option, value)\n\n    def add_section(self, section):\n        self._validate_value_types(section=section)\n        super().add_section(section)\n\n    def _read_defaults(self, defaults):\n        try:\n            hold_interpolation = self._interpolation\n            self._interpolation = Interpolation()\n            self.read_dict({self.default_section: defaults})\n        finally:\n            self._interpolation = hold_interpolation\n\n\nclass SafeConfigParser(ConfigParser):\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        warnings.warn(\n            "The SafeConfigParser class has been renamed to ConfigParser "\n            "in Python 3.2. This alias will be removed in Python 3.12."\n            " Use ConfigParser directly instead.",\n            DeprecationWarning, stacklevel=2\n        )\n\n\nclass SectionProxy(MutableMapping):\n\n    def __init__(self, parser, name):\n        self._parser = parser\n        self._name = name\n        for conv in parser.converters:\n            key = \'get\' + conv\n            getter = functools.partial(self.get, _impl=getattr(parser, key))\n            setattr(self, key, getter)\n\n    def __repr__(self):\n        return \'<Section: {}>\'.format(self._name)\n\n    def __getitem__(self, key):\n        if not self._parser.has_option(self._name, key):\n            raise KeyError(key)\n        return self._parser.get(self._name, key)\n\n    def __setitem__(self, key, value):\n        self._parser._validate_value_types(option=key, value=value)\n        return self._parser.set(self._name, key, value)\n\n    def __delitem__(self, key):\n        if not (self._parser.has_option(self._name, key) and\n                self._parser.remove_option(self._name, key)):\n            raise KeyError(key)\n\n    def __contains__(self, key):\n        return self._parser.has_option(self._name, key)\n\n    def __len__(self):\n        return len(self._options())\n\n    def __iter__(self):\n        return self._options().__iter__()\n\n    def _options(self):\n        if self._name != self._parser.default_section:\n            return self._parser.options(self._name)\n        else:\n            return self._parser.defaults()\n\n    @property\n    def parser(self):\n        return self._parser\n\n    @property\n    def name(self):\n        return self._name\n\n    def get(self, option, fallback=None, *, raw=False, vars=None,\n            _impl=None, **kwargs):\n        if not _impl:\n            _impl = self._parser.get\n        return _impl(self._name, option, raw=raw, vars=vars,\n                     fallback=fallback, **kwargs)\n\n\nclass ConverterMapping(MutableMapping):\n\n    GETTERCRE = re.compile(r"^get(?P<name>.+)$")\n\n    def __init__(self, parser):\n        self._parser = parser\n        self._data = {}\n        for getter in dir(self._parser):\n            m = self.GETTERCRE.match(getter)\n            if not m or not callable(getattr(self._parser, getter)):\n                continue\n            self._data[m.group(\'name\')] = None   # See class docstring.\n\n    def __getitem__(self, key):\n        return self._data[key]\n\n    def __setitem__(self, key, value):\n        try:\n            k = \'get\' + key\n        except TypeError:\n            raise ValueError(\'Incompatible key: {} (type: {})\'\n                             \'\'.format(key, type(key)))\n        if k == \'get\':\n            raise ValueError(\'Incompatible key: cannot use "" as a name\')\n        self._data[key] = value\n        func = functools.partial(self._parser._get_conv, conv=value)\n        func.converter = value\n        setattr(self._parser, k, func)\n        for proxy in self._parser.values():\n            getter = functools.partial(proxy.get, _impl=func)\n            setattr(proxy, k, getter)\n\n    def __delitem__(self, key):\n        try:\n            k = \'get\' + (key or None)\n        except TypeError:\n            raise KeyError(key)\n        del self._data[key]\n        for inst in itertools.chain((self._parser,), self._parser.values()):\n            try:\n                delattr(inst, k)\n            except AttributeError:\n                continue\n\n    def __iter__(self):\n        return iter(self._data)\n\n    def __len__(self):\n        return len(self._data)\n')
    __stickytape_write_module('language.py', b'\nEN = "en"\nJA = "ja"\n\nLanguage = {\n    "en": {\n        "help": """"{num}": Toggle on/off\n"{num}!{num}": Toggle Selection on/off\n"c": Select code file""",\n        "file_not_selected": "File not selected",\n        "loading": "Loading...",\n        "saving": "Saving...",\n        "send_code": "Send",\n        "disable_code": "Disable",\n        "pls_enter_ip": "Please enter your WiiU IPAddress",\n        "ip_address": "IP Address",\n        "connecting": "Connecting...",\n        "connected": "Connected",\n        "main_connected": "Connected",\n        "main_no_connection": "NoConnection",\n        "disconnected": "Disconnected",\n        "error_screenshot": "An error has occurred. The error message will be displayed in 5 seconds. Please send a screenshot to iranjin#4548.",\n        "tcp_status": "TCPStatus",\n        "tab": {\n            "send": "Send",\n            "disable": "Disable",\n            "connect": "Connect/Disconnect",\n            "code_manager": "CodeManager",\n        },\n    },\n    "ja": {\n        "help": """"{num}": Toggle on/off\n"{num}!{num}": Toggle Selection on/off\n"c": Select code file""",\n        "file_not_selected": "\xe3\x83\x95\xe3\x82\xa1\xe3\x82\xa4\xe3\x83\xab\xe3\x81\x8c\xe9\x81\xb8\xe6\x8a\x9e\xe3\x81\x95\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3\x81\xbe\xe3\x81\x9b\xe3\x82\x93",\n        "loading": "\xe8\xaa\xad\xe3\x81\xbf\xe8\xbe\xbc\xe3\x81\xbf\xe4\xb8\xad...",\n        "saving": "\xe4\xbf\x9d\xe5\xad\x98\xe4\xb8\xad...",\n        "send_code": "\xe9\x80\x81\xe4\xbf\xa1",\n        "disable_code": "\xe8\xa7\xa3\xe9\x99\xa4",\n        "pls_enter_ip": "WiiU\xe3\x81\xaeIP\xe3\x82\xa2\xe3\x83\x89\xe3\x83\xac\xe3\x82\xb9\xe3\x82\x92\xe5\x85\xa5\xe5\x8a\x9b\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84",\n        "ip_address": "IP\xe3\x82\xa2\xe3\x83\x89\xe3\x83\xac\xe3\x82\xb9",\n        "connecting": "\xe6\x8e\xa5\xe7\xb6\x9a\xe4\xb8\xad...",\n        "connected": "\xe6\x8e\xa5\xe7\xb6\x9a\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f",\n        "main_connected": "\xe6\x8e\xa5\xe7\xb6\x9a\xe6\xb8\x88\xe3\x81\xbf",\n        "main_no_connection": "\xe9\x9d\x9e\xe6\x8e\xa5\xe7\xb6\x9a",\n        "disconnected": "\xe5\x88\x87\xe6\x96\xad\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f",\n        "error_screenshot": "\xe3\x82\xa8\xe3\x83\xa9\xe3\x83\xbc\xe3\x81\x8c\xe7\x99\xba\xe7\x94\x9f\xe3\x81\x97\xe3\x81\xbe\xe3\x81\x97\xe3\x81\x9f\xe3\x80\x82\xe3\x82\xa8\xe3\x83\xa9\xe3\x83\xbc\xe3\x83\xa1\xe3\x83\x83\xe3\x82\xbb\xe3\x83\xbc\xe3\x82\xb8\xe3\x81\x8c5\xe7\xa7\x92\xe5\xbe\x8c\xe3\x81\xab\xe8\xa1\xa8\xe7\xa4\xba\xe3\x81\x95\xe3\x82\x8c\xe3\x81\xbe\xe3\x81\x99\xe3\x80\x82\xe3\x82\xb9\xe3\x82\xaf\xe3\x83\xaa\xe3\x83\xbc\xe3\x83\xb3\xe3\x82\xb7\xe3\x83\xa7\xe3\x83\x83\xe3\x83\x88\xe3\x82\x92iranjin#4548\xe3\x81\xab\xe9\x80\x81\xe4\xbf\xa1\xe3\x81\x97\xe3\x81\xa6\xe3\x81\x8f\xe3\x81\xa0\xe3\x81\x95\xe3\x81\x84\xe3\x80\x82",\n        "tcp_status": "TCP\xe3\x82\xb9\xe3\x83\x86\xe3\x83\xbc\xe3\x82\xbf\xe3\x82\xb9",\n        "tab": {\n            "send": "\xe9\x80\x81\xe4\xbf\xa1",\n            "disable": "\xe8\xa7\xa3\xe9\x99\xa4",\n            "connect": "\xe6\x8e\xa5\xe7\xb6\x9a/\xe5\x88\x87\xe6\x96\xad",\n            "code_manager": "\xe3\x82\xb3\xe3\x83\xbc\xe3\x83\x89\xe3\x83\x9e\xe3\x83\x8d\xe3\x83\xbc\xe3\x82\xb8\xe3\x83\xa3\xe3\x83\xbc",\n        },\n    }\n}\n')
    __stickytape_write_module('tcp.py', b'\nimport socket\nimport struct\nimport re\n\nfrom enum import Enum\nfrom cstr import *\n\nclass CMD(Enum):\n    POKE_8                      = b\'\\x01\'\n    POKE_16                     = b\'\\x02\'\n    POKE_32                     = b\'\\x03\'\n    READ_MEMORY                 = b\'\\x04\'\n    READ_MEMORY_KERNEL          = b\'\\x05\'\n    VALIDATE_ADDRESS_RANGE      = b\'\\x06\'\n    MEMORY_DISASSEMBLE          = b\'\\x08\'\n    # READ_MEMORY_COMPRESSED    = b\'\\x09\'\n    KERNEL_WRITE                = b\'\\x0B\' \n    KERNEL_READ                 = b\'\\x0C\'\n    # TAKE_SCREENSHOT            = b\'\\x0D\'\n    UPLOAD_MEMORY               = b\'\\x41\'\n    SERVER_STATUS               = b\'\\x50\'\n    GET_DATA_BUFFER_SIZE        = b\'\\x51\'\n    READ_FILE                   = b\'\\x52\'\n    READ_DIRECTORY              = b\'\\x53\'\n    REPLACE_FILE                = b\'\\x54\'\n    GET_CODE_HANDLER_ADDRESS    = b\'\\x55\'\n    READ_THREADS                = b\'\\x56\'\n    ACCOUNT_IDENTIFIER          = b\'\\x57\'\n    # WRITE_SCREEN              = b\'\\x58\'\n    FOLLOW_POINTER              = b\'\\x60\'\n    REMOTE_PROCEDURE_CALL       = b\'\\x70\'\n    GET_SYMBOL                  = b\'\\x71\'\n    MEMORY_SEARCH               = b\'\\x72\'\n    ADVANCED_MEMORY_SEARCH      = b\'\\x73\'\n    EXECUTE_ASSEMBLY            = b\'\\x81\'\n    PAUSE_CONSOLE               = b\'\\x82\'\n    RESUME_CONSOLE              = b\'\\x83\'\n    IS_CONSOLE_PAUSED           = b\'\\x84\'\n    GET_SERVER_VERSION          = b\'\\x99\'\n    GET_OS_VERSION              = b\'\\x9A\'\n    SET_DATA_BREAKPOINT         = b\'\\xA0\'\n    SET_INSTRUCTION_BREAKPOINT  = b\'\\xA2\'\n    TOGGLE_BREAKPOINT           = b\'\\xA5\'\n    REMOVE_ALL_BREAKPOINT       = b\'\\xA6\'\n    POKE_REGISTERS              = b\'\\xA7\'\n    GET_STACK_TRACE             = b\'\\xA8\'\n    GET_ENTRY_POINT_ADDRESS     = b\'\\xB1\'\n    RUN_KERNEL_COPY_SERVICE     = b\'\\xCD\'\n    IOSU_HAX_READ_FILE          = b\'\\xD0\'\n    GET_VERSION_HASH            = b\'\\xE0\'\n    PERSIST_ASSEMBLY            = b\'\\xE1\'\n    CLEAR_ASSEMBLY              = b\'\\xE2\'\n\n\n\nclass TCPGecko:\n\n    def __init__(self, ip_address: str = None, port: int = 7331, clear_cafe: bool = False):\n        self.__timeout = 5.0\n        self.__connected = False\n        self.__ip_address = None\n        self.__port = port\n        self.clear_cafe = clear_cafe\n        if ip_address:\n            self.setIpAddress(ip_address)\n        self.socketInit()\n        \n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.__connected:\n            self.disconnect()\n    \n    \n    def socketInit(self):\n        self.__connected = False\n        self.__s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        return self\n\n\n    def setTimeout(self, timeout: float):\n        self.__timeout = timeout\n\n        return self\n    \n\n    def setIpAddress(self, ip_address: str, port: int = 7331):\n        if re.match(r\'^192\\.168\\.\\d{1,3}\\.\\d{1,3}$\', ip_address) is None:\n            raise ValueError("Invalid ip address format \'%s\'" % (ip_address))\n        self.__ip_address = ip_address\n        self.__port = port\n\n        return self\n\n\n    @property\n    def ip_address(self):\n        return self.__ip_address\n    \n\n    def connect(self, ip_address: str = None, port: int = None, timeout: float = None):\n        if self.__connected:\n            return self\n        \n        self.__s.settimeout((timeout if timeout else self.__timeout))\n\n        try:\n            self.__s.connect((\n                (ip_address if ip_address else self.__ip_address),\n                ((port if port else self.__port))))\n        except TimeoutError as e:\n            self.__connected = False\n            raise e\n        else:\n            self.__ip_address = ip_address\n            self.__connected = True\n\n        return self\n\n\n    def disconnect(self):\n        self.__connected = False\n\n        if not self.__connected:\n            return self\n\n        self.__s.close()\n\n        return self\n    \n\n    def isConnected(self):\n        return self.__connected\n    \n\n    def getTitleId(self):...\n\n\n    def poke(\n            self,\n            address: int,\n            value: int,\n            size: int = 32\n        ):\n\n        if   size == 8:  cmd = CMD.POKE_8.value\n        elif size == 16: cmd = CMD.POKE_16.value\n        elif size == 32: cmd = CMD.POKE_32.value\n        else:\n            raise ValueError("Invalid int value size: %d" % (size))\n\n        self.__s.send(cmd)\n        self.__s.send(struct.pack(">II", address, value))\n\n        return self\n\n    \n    def assemblyRamWrite(self, _asm_code: cstr):\n        asm_code = cstr(_asm_code.replace("#", ""))\n\n        if not (asm_code or asm_code.isCode()):\n            raise ValueError("The code is invalid: %s" % (asm_code))\n        \n        code = asm_code.formatCode().splitRamWrite()\n\n        for line in code:\n            self.poke(line[0], line[1])\n        \n        return self\n    \n    \n    def sendCafeCode(self, _cafe_code: cstr):\n        cafe_code = cstr(_cafe_code.replace("#", ""))\n\n        if not (cafe_code or cafe_code.isCode()):\n            raise ValueError("The code is invalid: %s" % (cafe_code))\n        \n        code = cafe_code.formatCode().splitCafeCode()\n        code.append(0x0)\n\n        self.switchCafeCode(False)\n\n        for i, value in enumerate(code):\n            self.poke(0x01133000 + i * 4, value)\n\n        self.switchCafeCode(True)\n\n        return self\n    \n\n    def switchCafeCode(self, switch: bool):\n        self.poke(0x10014CFC, (0x1 if switch else 0x0))\n\n        return self\n    \n\n    def disableCafeCode(self):\n        self.switchCafeCode(False)\n        if self.clear_cafe:\n            self.__clearCafeCode()\n\n        return self\n\n\n    def __clearCafeCode(self, _range: int = 2656):\n        for i in range(_range):\n            self.poke(0x01133000 + i * 4, 0x0)\n')
    __stickytape_write_module('terminal.py', b'\nimport platform_copy as platform\nimport os\n\nfrom misc import *\n\nclass Terminal:\n    \n    def __init__(self, line: int = 99):\n        self.__clear_command = None\n        self.__line = line\n\n        self.__getClearCmd()\n    \n\n    def __getClearCmd(self):\n        sys = platform.system()\n        pf = platform.platform()\n\n        if "iOS" in pf:\n            self.__clear_command = None\n            return None\n        \n        if sys == "Windows":\n            self.__clear_command = "cls"\n            return "Windows"\n        elif sys == "Darwin":\n            self.__clear_command = "clear"\n            return "macos"\n        elif sys == "Linux":\n            self.__clear_command = "clear"\n            return "linux"\n        else:\n            self.__clear_command = None\n            return None\n        \n\n    def cls(self):\n        if not self.__clear_command:\n            print("\\n" * self.__line)\n            return\n        os.system(self.__clear_command)\n\n\n    @staticmethod\n    def elementSelecter(elements: list, msg: str, _exit: bool = False):\n        elements = list(elements)\n\n        if not elements:\n            return None\n\n        t = Terminal()\n\n        while True:\n            t.cls()\n\n            for i, element in enumerate(elements):\n                print("%s \xe2\x94\x82 %s" % (\n                        str(i + 1).rjust(digit(len(elements))), element))\n            \n            index_s = input("%s \\\\ " % (msg))\n\n            if _exit and not index_s:\n                return None\n\n            t.cls()\n\n            try:\n                index = int(index_s) - 1\n                if index < 0:\n                    continue\n                return elements[index]\n            except ValueError: continue\n            except IndexError: continue\n    ')
    __stickytape_write_module('platform_copy.py', b'\n__version__ = \'1.0.8\'\n\nimport collections\nimport os\nimport re\nimport sys\nimport functools\nimport itertools\n\n_ver_stages = {\n    # any string not found in this dict, will get 0 assigned\n    \'dev\': 10,\n    \'alpha\': 20, \'a\': 20,\n    \'beta\': 30, \'b\': 30,\n    \'c\': 40,\n    \'RC\': 50, \'rc\': 50,\n    # number, will get 100 assigned\n    \'pl\': 200, \'p\': 200,\n}\n\n_component_re = re.compile(r\'([0-9]+|[._+-])\')\n\ndef _comparable_version(version):\n    result = []\n    for v in _component_re.split(version):\n        if v not in \'._+-\':\n            try:\n                v = int(v, 10)\n                t = 100\n            except ValueError:\n                t = _ver_stages.get(v, 0)\n            result.extend((t, v))\n    return result\n\n### Platform specific APIs\n\n_libc_search = re.compile(b\'(__libc_init)\'\n                          b\'|\'\n                          b\'(GLIBC_([0-9.]+))\'\n                          b\'|\'\n                          br\'(libc(_\\w+)?\\.so(?:\\.(\\d[0-9.]*))?)\', re.ASCII)\n\ndef libc_ver(executable=None, lib=\'\', version=\'\', chunksize=16384):\n\n    """ Tries to determine the libc version that the file executable\n        (which defaults to the Python interpreter) is linked against.\n\n        Returns a tuple of strings (lib,version) which default to the\n        given parameters in case the lookup fails.\n\n        Note that the function has intimate knowledge of how different\n        libc versions add symbols to the executable and thus is probably\n        only usable for executables compiled using gcc.\n\n        The file is read and scanned in chunks of chunksize bytes.\n\n    """\n    if not executable:\n        try:\n            ver = os.confstr(\'CS_GNU_LIBC_VERSION\')\n            # parse \'glibc 2.28\' as (\'glibc\', \'2.28\')\n            parts = ver.split(maxsplit=1)\n            if len(parts) == 2:\n                return tuple(parts)\n        except (AttributeError, ValueError, OSError):\n            # os.confstr() or CS_GNU_LIBC_VERSION value not available\n            pass\n\n        executable = sys.executable\n\n        if not executable:\n            # sys.executable is not set.\n            return lib, version\n\n    V = _comparable_version\n    # We use os.path.realpath()\n    # here to work around problems with Cygwin not being\n    # able to open symlinks for reading\n    executable = os.path.realpath(executable)\n    with open(executable, \'rb\') as f:\n        binary = f.read(chunksize)\n        pos = 0\n        while pos < len(binary):\n            if b\'libc\' in binary or b\'GLIBC\' in binary:\n                m = _libc_search.search(binary, pos)\n            else:\n                m = None\n            if not m or m.end() == len(binary):\n                chunk = f.read(chunksize)\n                if chunk:\n                    binary = binary[max(pos, len(binary) - 1000):] + chunk\n                    pos = 0\n                    continue\n                if not m:\n                    break\n            libcinit, glibc, glibcversion, so, threads, soversion = [\n                s.decode(\'latin1\') if s is not None else s\n                for s in m.groups()]\n            if libcinit and not lib:\n                lib = \'libc\'\n            elif glibc:\n                if lib != \'glibc\':\n                    lib = \'glibc\'\n                    version = glibcversion\n                elif V(glibcversion) > V(version):\n                    version = glibcversion\n            elif so:\n                if lib != \'glibc\':\n                    lib = \'libc\'\n                    if soversion and (not version or V(soversion) > V(version)):\n                        version = soversion\n                    if threads and version[-len(threads):] != threads:\n                        version = version + threads\n            pos = m.end()\n    return lib, version\n\ndef _norm_version(version, build=\'\'):\n\n    """ Normalize the version and build strings and return a single\n        version string using the format major.minor.build (or patchlevel).\n    """\n    l = version.split(\'.\')\n    if build:\n        l.append(build)\n    try:\n        strings = list(map(str, map(int, l)))\n    except ValueError:\n        strings = l\n    version = \'.\'.join(strings[:3])\n    return version\n\n_ver_output = re.compile(r\'(?:([\\w ]+) ([\\w.]+) \'\n                         r\'.*\'\n                         r\'\\[.* ([\\d.]+)\\])\')\n\n# Examples of VER command output:\n#\n#   Windows 2000:  Microsoft Windows 2000 [Version 5.00.2195]\n#   Windows XP:    Microsoft Windows XP [Version 5.1.2600]\n#   Windows Vista: Microsoft Windows [Version 6.0.6002]\n#\n# Note that the "Version" string gets localized on different\n# Windows versions.\n\ndef _syscmd_ver(system=\'\', release=\'\', version=\'\',\n\n               supported_platforms=(\'win32\', \'win16\', \'dos\')):\n\n    """ Tries to figure out the OS version used and returns\n        a tuple (system, release, version).\n\n        It uses the "ver" shell command for this which is known\n        to exists on Windows, DOS. XXX Others too ?\n\n        In case this fails, the given parameters are used as\n        defaults.\n\n    """\n    if sys.platform not in supported_platforms:\n        return system, release, version\n\n    # Try some common cmd strings\n    import subprocess\n    for cmd in (\'ver\', \'command /c ver\', \'cmd /c ver\'):\n        try:\n            info = subprocess.check_output(cmd,\n                                           stdin=subprocess.DEVNULL,\n                                           stderr=subprocess.DEVNULL,\n                                           text=True,\n                                           shell=True)\n        except (OSError, subprocess.CalledProcessError) as why:\n            #print(\'Command %s failed: %s\' % (cmd, why))\n            continue\n        else:\n            break\n    else:\n        return system, release, version\n\n    # Parse the output\n    info = info.strip()\n    m = _ver_output.match(info)\n    if m is not None:\n        system, release, version = m.groups()\n        # Strip trailing dots from version and release\n        if release[-1] == \'.\':\n            release = release[:-1]\n        if version[-1] == \'.\':\n            version = version[:-1]\n        # Normalize the version and build strings (eliminating additional\n        # zeros)\n        version = _norm_version(version)\n    return system, release, version\n\n_WIN32_CLIENT_RELEASES = {\n    (5, 0): "2000",\n    (5, 1): "XP",\n    # Strictly, 5.2 client is XP 64-bit, but platform.py historically\n    # has always called it 2003 Server\n    (5, 2): "2003Server",\n    (5, None): "post2003",\n\n    (6, 0): "Vista",\n    (6, 1): "7",\n    (6, 2): "8",\n    (6, 3): "8.1",\n    (6, None): "post8.1",\n\n    (10, 0): "10",\n    (10, None): "post10",\n}\n\n# Server release name lookup will default to client names if necessary\n_WIN32_SERVER_RELEASES = {\n    (5, 2): "2003Server",\n\n    (6, 0): "2008Server",\n    (6, 1): "2008ServerR2",\n    (6, 2): "2012Server",\n    (6, 3): "2012ServerR2",\n    (6, None): "post2012ServerR2",\n}\n\ndef win32_is_iot():\n    return win32_edition() in (\'IoTUAP\', \'NanoServer\', \'WindowsCoreHeadless\', \'IoTEdgeOS\')\n\ndef win32_edition():\n    try:\n        try:\n            import winreg\n        except ImportError:\n            import _winreg as winreg\n    except ImportError:\n        pass\n    else:\n        try:\n            cvkey = r\'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\'\n            with winreg.OpenKeyEx(winreg.HKEY_LOCAL_MACHINE, cvkey) as key:\n                return winreg.QueryValueEx(key, \'EditionId\')[0]\n        except OSError:\n            pass\n\n    return None\n\ndef win32_ver(release=\'\', version=\'\', csd=\'\', ptype=\'\'):\n    try:\n        from sys import getwindowsversion\n    except ImportError:\n        return release, version, csd, ptype\n\n    winver = getwindowsversion()\n    try:\n        major, minor, build = map(int, _syscmd_ver()[2].split(\'.\'))\n    except ValueError:\n        major, minor, build = winver.platform_version or winver[:3]\n    version = \'{0}.{1}.{2}\'.format(major, minor, build)\n\n    release = (_WIN32_CLIENT_RELEASES.get((major, minor)) or\n               _WIN32_CLIENT_RELEASES.get((major, None)) or\n               release)\n\n    # getwindowsversion() reflect the compatibility mode Python is\n    # running under, and so the service pack value is only going to be\n    # valid if the versions match.\n    if winver[:2] == (major, minor):\n        try:\n            csd = \'SP{}\'.format(winver.service_pack_major)\n        except AttributeError:\n            if csd[:13] == \'Service Pack \':\n                csd = \'SP\' + csd[13:]\n\n    # VER_NT_SERVER = 3\n    if getattr(winver, \'product_type\', None) == 3:\n        release = (_WIN32_SERVER_RELEASES.get((major, minor)) or\n                   _WIN32_SERVER_RELEASES.get((major, None)) or\n                   release)\n\n    try:\n        try:\n            import winreg\n        except ImportError:\n            import _winreg as winreg\n    except ImportError:\n        pass\n    else:\n        try:\n            cvkey = r\'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\'\n            with winreg.OpenKeyEx(winreg.HKEY_LOCAL_MACHINE, cvkey) as key:\n                ptype = winreg.QueryValueEx(key, \'CurrentType\')[0]\n        except OSError:\n            pass\n\n    return release, version, csd, ptype\n\n\ndef _mac_ver_xml():\n    fn = \'/System/Library/CoreServices/SystemVersion.plist\'\n    if not os.path.exists(fn):\n        return None\n\n    try:\n        import plistlib\n    except ImportError:\n        return None\n\n    with open(fn, \'rb\') as f:\n        pl = plistlib.load(f)\n    release = pl[\'ProductVersion\']\n    versioninfo = (\'\', \'\', \'\')\n    machine = os.uname().machine\n    if machine in (\'ppc\', \'Power Macintosh\'):\n        # Canonical name\n        machine = \'PowerPC\'\n\n    return release, versioninfo, machine\n\n\ndef mac_ver(release=\'\', versioninfo=(\'\', \'\', \'\'), machine=\'\'):\n\n    """ Get macOS version information and return it as tuple (release,\n        versioninfo, machine) with versioninfo being a tuple (version,\n        dev_stage, non_release_version).\n\n        Entries which cannot be determined are set to the parameter values\n        which default to \'\'. All tuple entries are strings.\n    """\n\n    # First try reading the information from an XML file which should\n    # always be present\n    info = _mac_ver_xml()\n    if info is not None:\n        return info\n\n    # If that also doesn\'t work return the default values\n    return release, versioninfo, machine\n\ndef _java_getprop(name, default):\n\n    from java.lang import System\n    try:\n        value = System.getProperty(name)\n        if value is None:\n            return default\n        return value\n    except AttributeError:\n        return default\n\ndef java_ver(release=\'\', vendor=\'\', vminfo=(\'\', \'\', \'\'), osinfo=(\'\', \'\', \'\')):\n\n    """ Version interface for Jython.\n\n        Returns a tuple (release, vendor, vminfo, osinfo) with vminfo being\n        a tuple (vm_name, vm_release, vm_vendor) and osinfo being a\n        tuple (os_name, os_version, os_arch).\n\n        Values which cannot be determined are set to the defaults\n        given as parameters (which all default to \'\').\n\n    """\n    # Import the needed APIs\n    try:\n        import java.lang\n    except ImportError:\n        return release, vendor, vminfo, osinfo\n\n    vendor = _java_getprop(\'java.vendor\', vendor)\n    release = _java_getprop(\'java.version\', release)\n    vm_name, vm_release, vm_vendor = vminfo\n    vm_name = _java_getprop(\'java.vm.name\', vm_name)\n    vm_vendor = _java_getprop(\'java.vm.vendor\', vm_vendor)\n    vm_release = _java_getprop(\'java.vm.version\', vm_release)\n    vminfo = vm_name, vm_release, vm_vendor\n    os_name, os_version, os_arch = osinfo\n    os_arch = _java_getprop(\'java.os.arch\', os_arch)\n    os_name = _java_getprop(\'java.os.name\', os_name)\n    os_version = _java_getprop(\'java.os.version\', os_version)\n    osinfo = os_name, os_version, os_arch\n\n    return release, vendor, vminfo, osinfo\n\n### System name aliasing\n\ndef system_alias(system, release, version):\n\n    """ Returns (system, release, version) aliased to common\n        marketing names used for some systems.\n\n        It also does some reordering of the information in some cases\n        where it would otherwise cause confusion.\n\n    """\n    if system == \'SunOS\':\n        # Sun\'s OS\n        if release < \'5\':\n            # These releases use the old name SunOS\n            return system, release, version\n        # Modify release (marketing release = SunOS release - 3)\n        l = release.split(\'.\')\n        if l:\n            try:\n                major = int(l[0])\n            except ValueError:\n                pass\n            else:\n                major = major - 3\n                l[0] = str(major)\n                release = \'.\'.join(l)\n        if release < \'6\':\n            system = \'Solaris\'\n        else:\n            # XXX Whatever the new SunOS marketing name is...\n            system = \'Solaris\'\n\n    elif system in (\'win32\', \'win16\'):\n        # In case one of the other tricks\n        system = \'Windows\'\n\n    # bpo-35516: Don\'t replace Darwin with macOS since input release and\n    # version arguments can be different than the currently running version.\n\n    return system, release, version\n\n### Various internal helpers\n\ndef _platform(*args):\n\n    """ Helper to format the platform string in a filename\n        compatible format e.g. "system-version-machine".\n    """\n    # Format the platform string\n    platform = \'-\'.join(x.strip() for x in filter(len, args))\n\n    # Cleanup some possible filename obstacles...\n    platform = platform.replace(\' \', \'_\')\n    platform = platform.replace(\'/\', \'-\')\n    platform = platform.replace(\'\\\\\', \'-\')\n    platform = platform.replace(\':\', \'-\')\n    platform = platform.replace(\';\', \'-\')\n    platform = platform.replace(\'"\', \'-\')\n    platform = platform.replace(\'(\', \'-\')\n    platform = platform.replace(\')\', \'-\')\n\n    # No need to report \'unknown\' information...\n    platform = platform.replace(\'unknown\', \'\')\n\n    # Fold \'--\'s and remove trailing \'-\'\n    while 1:\n        cleaned = platform.replace(\'--\', \'-\')\n        if cleaned == platform:\n            break\n        platform = cleaned\n    while platform[-1] == \'-\':\n        platform = platform[:-1]\n\n    return platform\n\ndef _node(default=\'\'):\n\n    """ Helper to determine the node name of this machine.\n    """\n    try:\n        import socket\n    except ImportError:\n        # No sockets...\n        return default\n    try:\n        return socket.gethostname()\n    except OSError:\n        # Still not working...\n        return default\n\ndef _follow_symlinks(filepath):\n\n    """ In case filepath is a symlink, follow it until a\n        real file is reached.\n    """\n    filepath = os.path.abspath(filepath)\n    while os.path.islink(filepath):\n        filepath = os.path.normpath(\n            os.path.join(os.path.dirname(filepath), os.readlink(filepath)))\n    return filepath\n\n\ndef _syscmd_file(target, default=\'\'):\n\n    """ Interface to the system\'s file command.\n\n        The function uses the -b option of the file command to have it\n        omit the filename in its output. Follow the symlinks. It returns\n        default in case the command should fail.\n\n    """\n    if sys.platform in (\'dos\', \'win32\', \'win16\'):\n        # XXX Others too ?\n        return default\n\n    try:\n        import subprocess\n    except ImportError:\n        return default\n    target = _follow_symlinks(target)\n    # "file" output is locale dependent: force the usage of the C locale\n    # to get deterministic behavior.\n    env = dict(os.environ, LC_ALL=\'C\')\n    try:\n        # -b: do not prepend filenames to output lines (brief mode)\n        output = subprocess.check_output([\'file\', \'-b\', target],\n                                         stderr=subprocess.DEVNULL,\n                                         env=env)\n    except (OSError, subprocess.CalledProcessError):\n        return default\n    if not output:\n        return default\n    # With the C locale, the output should be mostly ASCII-compatible.\n    # Decode from Latin-1 to prevent Unicode decode error.\n    return output.decode(\'latin-1\')\n\n### Information about the used architecture\n\n# Default values for architecture; non-empty strings override the\n# defaults given as parameters\n_default_architecture = {\n    \'win32\': (\'\', \'WindowsPE\'),\n    \'win16\': (\'\', \'Windows\'),\n    \'dos\': (\'\', \'MSDOS\'),\n}\n\ndef architecture(executable=sys.executable, bits=\'\', linkage=\'\'):\n\n    """ Queries the given executable (defaults to the Python interpreter\n        binary) for various architecture information.\n\n        Returns a tuple (bits, linkage) which contains information about\n        the bit architecture and the linkage format used for the\n        executable. Both values are returned as strings.\n\n        Values that cannot be determined are returned as given by the\n        parameter presets. If bits is given as \'\', the sizeof(pointer)\n        (or sizeof(long) on Python version < 1.5.2) is used as\n        indicator for the supported pointer size.\n\n        The function relies on the system\'s "file" command to do the\n        actual work. This is available on most if not all Unix\n        platforms. On some non-Unix platforms where the "file" command\n        does not exist and the executable is set to the Python interpreter\n        binary defaults from _default_architecture are used.\n\n    """\n    # Use the sizeof(pointer) as default number of bits if nothing\n    # else is given as default.\n    if not bits:\n        import struct\n        size = struct.calcsize(\'P\')\n        bits = str(size * 8) + \'bit\'\n\n    # Get data from the \'file\' system command\n    if executable:\n        fileout = _syscmd_file(executable, \'\')\n    else:\n        fileout = \'\'\n\n    if not fileout and \\\n       executable == sys.executable:\n        # "file" command did not return anything; we\'ll try to provide\n        # some sensible defaults then...\n        if sys.platform in _default_architecture:\n            b, l = _default_architecture[sys.platform]\n            if b:\n                bits = b\n            if l:\n                linkage = l\n        return bits, linkage\n\n    if \'executable\' not in fileout and \'shared object\' not in fileout:\n        # Format not supported\n        return bits, linkage\n\n    # Bits\n    if \'32-bit\' in fileout:\n        bits = \'32bit\'\n    elif \'64-bit\' in fileout:\n        bits = \'64bit\'\n\n    # Linkage\n    if \'ELF\' in fileout:\n        linkage = \'ELF\'\n    elif \'PE\' in fileout:\n        # E.g. Windows uses this format\n        if \'Windows\' in fileout:\n            linkage = \'WindowsPE\'\n        else:\n            linkage = \'PE\'\n    elif \'COFF\' in fileout:\n        linkage = \'COFF\'\n    elif \'MS-DOS\' in fileout:\n        linkage = \'MSDOS\'\n    else:\n        # XXX the A.OUT format also falls under this class...\n        pass\n\n    return bits, linkage\n\n\ndef _get_machine_win32():\n    # Try to use the PROCESSOR_* environment variables\n    # available on Win XP and later; see\n    # http://support.microsoft.com/kb/888731 and\n    # http://www.geocities.com/rick_lively/MANUALS/ENV/MSWIN/PROCESSI.HTM\n\n    # WOW64 processes mask the native architecture\n    return (\n        os.environ.get(\'PROCESSOR_ARCHITEW6432\', \'\') or\n        os.environ.get(\'PROCESSOR_ARCHITECTURE\', \'\')\n    )\n\n\nclass _Processor:\n    @classmethod\n    def get(cls):\n        func = getattr(cls, f\'get_{sys.platform}\', cls.from_subprocess)\n        return func() or \'\'\n\n    def get_win32():\n        return os.environ.get(\'PROCESSOR_IDENTIFIER\', _get_machine_win32())\n\n    def get_OpenVMS():\n        try:\n            import vms_lib\n        except ImportError:\n            pass\n        else:\n            csid, cpu_number = vms_lib.getsyi(\'SYI$_CPU\', 0)\n            return \'Alpha\' if cpu_number >= 128 else \'VAX\'\n\n    def from_subprocess():\n        """\n        Fall back to `uname -p`\n        """\n        try:\n            import subprocess\n        except ImportError:\n            return None\n        try:\n            return subprocess.check_output(\n                [\'uname\', \'-p\'],\n                stderr=subprocess.DEVNULL,\n                text=True,\n            ).strip()\n        except (OSError, subprocess.CalledProcessError):\n            pass\n\n\ndef _unknown_as_blank(val):\n    return \'\' if val == \'unknown\' else val\n\n\n### Portable uname() interface\n\nclass uname_result(\n    collections.namedtuple(\n        "uname_result_base",\n        "system node release version machine")\n        ):\n    """\n    A uname_result that\'s largely compatible with a\n    simple namedtuple except that \'processor\' is\n    resolved late and cached to avoid calling "uname"\n    except when needed.\n    """\n\n    _fields = (\'system\', \'node\', \'release\', \'version\', \'machine\', \'processor\')\n\n    @functools.cached_property\n    def processor(self):\n        return _unknown_as_blank(_Processor.get())\n\n    def __iter__(self):\n        return itertools.chain(\n            super().__iter__(),\n            (self.processor,)\n        )\n\n    @classmethod\n    def _make(cls, iterable):\n        # override factory to affect length check\n        num_fields = len(cls._fields) - 1\n        result = cls.__new__(cls, *iterable)\n        if len(result) != num_fields + 1:\n            msg = f\'Expected {num_fields} arguments, got {len(result)}\'\n            raise TypeError(msg)\n        return result\n\n    def __getitem__(self, key):\n        return tuple(self)[key]\n\n    def __len__(self):\n        return len(tuple(iter(self)))\n\n    def __reduce__(self):\n        return uname_result, tuple(self)[:len(self._fields) - 1]\n\n\n_uname_cache = None\n\n\ndef uname():\n\n    """ Fairly portable uname interface. Returns a tuple\n        of strings (system, node, release, version, machine, processor)\n        identifying the underlying platform.\n\n        Note that unlike the os.uname function this also returns\n        possible processor information as an additional tuple entry.\n\n        Entries which cannot be determined are set to \'\'.\n\n    """\n    global _uname_cache\n\n    if _uname_cache is not None:\n        return _uname_cache\n\n    # Get some infos from the builtin os.uname API...\n    try:\n        system, node, release, version, machine = infos = os.uname()\n    except AttributeError:\n        system = sys.platform\n        node = _node()\n        release = version = machine = \'\'\n        infos = ()\n\n    if not any(infos):\n        # uname is not available\n\n        # Try win32_ver() on win32 platforms\n        if system == \'win32\':\n            release, version, csd, ptype = win32_ver()\n            machine = machine or _get_machine_win32()\n\n        # Try the \'ver\' system command available on some\n        # platforms\n        if not (release and version):\n            system, release, version = _syscmd_ver(system)\n            # Normalize system to what win32_ver() normally returns\n            # (_syscmd_ver() tends to return the vendor name as well)\n            if system == \'Microsoft Windows\':\n                system = \'Windows\'\n            elif system == \'Microsoft\' and release == \'Windows\':\n                # Under Windows Vista and Windows Server 2008,\n                # Microsoft changed the output of the ver command. The\n                # release is no longer printed.  This causes the\n                # system and release to be misidentified.\n                system = \'Windows\'\n                if \'6.0\' == version[:3]:\n                    release = \'Vista\'\n                else:\n                    release = \'\'\n\n        # In case we still don\'t know anything useful, we\'ll try to\n        # help ourselves\n        if system in (\'win32\', \'win16\'):\n            if not version:\n                if system == \'win32\':\n                    version = \'32bit\'\n                else:\n                    version = \'16bit\'\n            system = \'Windows\'\n\n        elif system[:4] == \'java\':\n            release, vendor, vminfo, osinfo = java_ver()\n            system = \'Java\'\n            version = \', \'.join(vminfo)\n            if not version:\n                version = vendor\n\n    # System specific extensions\n    if system == \'OpenVMS\':\n        # OpenVMS seems to have release and version mixed up\n        if not release or release == \'0\':\n            release = version\n            version = \'\'\n\n    #  normalize name\n    if system == \'Microsoft\' and release == \'Windows\':\n        system = \'Windows\'\n        release = \'Vista\'\n\n    vals = system, node, release, version, machine\n    # Replace \'unknown\' values with the more portable \'\'\n    _uname_cache = uname_result(*map(_unknown_as_blank, vals))\n    return _uname_cache\n\n### Direct interfaces to some of the uname() return values\n\ndef system():\n\n    """ Returns the system/OS name, e.g. \'Linux\', \'Windows\' or \'Java\'.\n\n        An empty string is returned if the value cannot be determined.\n\n    """\n    return uname().system\n\ndef node():\n\n    """ Returns the computer\'s network name (which may not be fully\n        qualified)\n\n        An empty string is returned if the value cannot be determined.\n\n    """\n    return uname().node\n\ndef release():\n\n    """ Returns the system\'s release, e.g. \'2.2.0\' or \'NT\'\n\n        An empty string is returned if the value cannot be determined.\n\n    """\n    return uname().release\n\ndef version():\n\n    """ Returns the system\'s release version, e.g. \'#3 on degas\'\n\n        An empty string is returned if the value cannot be determined.\n\n    """\n    return uname().version\n\ndef machine():\n\n    """ Returns the machine type, e.g. \'i386\'\n\n        An empty string is returned if the value cannot be determined.\n\n    """\n    return uname().machine\n\ndef processor():\n\n    """ Returns the (true) processor name, e.g. \'amdk6\'\n\n        An empty string is returned if the value cannot be\n        determined. Note that many platforms do not provide this\n        information or simply return the same value as for machine(),\n        e.g.  NetBSD does this.\n\n    """\n    return uname().processor\n\n### Various APIs for extracting information from sys.version\n\n_sys_version_parser = re.compile(\n    r\'([\\w.+]+)\\s*\'  # "version<space>"\n    r\'\\(#?([^,]+)\'  # "(#buildno"\n    r\'(?:,\\s*([\\w ]*)\'  # ", builddate"\n    r\'(?:,\\s*([\\w :]*))?)?\\)\\s*\'  # ", buildtime)<space>"\n    r\'\\[([^\\]]+)\\]?\', re.ASCII)  # "[compiler]"\n\n_ironpython_sys_version_parser = re.compile(\n    r\'IronPython\\s*\'\n    r\'([\\d\\.]+)\'\n    r\'(?: \\(([\\d\\.]+)\\))?\'\n    r\' on (.NET [\\d\\.]+)\', re.ASCII)\n\n# IronPython covering 2.6 and 2.7\n_ironpython26_sys_version_parser = re.compile(\n    r\'([\\d.]+)\\s*\'\n    r\'\\(IronPython\\s*\'\n    r\'[\\d.]+\\s*\'\n    r\'\\(([\\d.]+)\\) on ([\\w.]+ [\\d.]+(?: \\(\\d+-bit\\))?)\\)\'\n)\n\n_pypy_sys_version_parser = re.compile(\n    r\'([\\w.+]+)\\s*\'\n    r\'\\(#?([^,]+),\\s*([\\w ]+),\\s*([\\w :]+)\\)\\s*\'\n    r\'\\[PyPy [^\\]]+\\]?\')\n\n_sys_version_cache = {}\n\ndef _sys_version(sys_version=None):\n\n    """ Returns a parsed version of Python\'s sys.version as tuple\n        (name, version, branch, revision, buildno, builddate, compiler)\n        referring to the Python implementation name, version, branch,\n        revision, build number, build date/time as string and the compiler\n        identification string.\n\n        Note that unlike the Python sys.version, the returned value\n        for the Python version will always include the patchlevel (it\n        defaults to \'.0\').\n\n        The function returns empty strings for tuple entries that\n        cannot be determined.\n\n        sys_version may be given to parse an alternative version\n        string, e.g. if the version was read from a different Python\n        interpreter.\n\n    """\n    # Get the Python version\n    if sys_version is None:\n        sys_version = sys.version\n\n    # Try the cache first\n    result = _sys_version_cache.get(sys_version, None)\n    if result is not None:\n        return result\n\n    # Parse it\n    if \'IronPython\' in sys_version:\n        # IronPython\n        name = \'IronPython\'\n        if sys_version.startswith(\'IronPython\'):\n            match = _ironpython_sys_version_parser.match(sys_version)\n        else:\n            match = _ironpython26_sys_version_parser.match(sys_version)\n\n        if match is None:\n            raise ValueError(\n                \'failed to parse IronPython sys.version: %s\' %\n                repr(sys_version))\n\n        version, alt_version, compiler = match.groups()\n        buildno = \'\'\n        builddate = \'\'\n\n    elif sys.platform.startswith(\'java\'):\n        # Jython\n        name = \'Jython\'\n        match = _sys_version_parser.match(sys_version)\n        if match is None:\n            raise ValueError(\n                \'failed to parse Jython sys.version: %s\' %\n                repr(sys_version))\n        version, buildno, builddate, buildtime, _ = match.groups()\n        if builddate is None:\n            builddate = \'\'\n        compiler = sys.platform\n\n    elif "PyPy" in sys_version:\n        # PyPy\n        name = "PyPy"\n        match = _pypy_sys_version_parser.match(sys_version)\n        if match is None:\n            raise ValueError("failed to parse PyPy sys.version: %s" %\n                             repr(sys_version))\n        version, buildno, builddate, buildtime = match.groups()\n        compiler = ""\n\n    else:\n        # CPython\n        match = _sys_version_parser.match(sys_version)\n        if match is None:\n            raise ValueError(\n                \'failed to parse CPython sys.version: %s\' %\n                repr(sys_version))\n        version, buildno, builddate, buildtime, compiler = \\\n              match.groups()\n        name = \'CPython\'\n        if builddate is None:\n            builddate = \'\'\n        elif buildtime:\n            builddate = builddate + \' \' + buildtime\n\n    if hasattr(sys, \'_git\'):\n        _, branch, revision = sys._git\n    elif hasattr(sys, \'_mercurial\'):\n        _, branch, revision = sys._mercurial\n    else:\n        branch = \'\'\n        revision = \'\'\n\n    # Add the patchlevel version if missing\n    l = version.split(\'.\')\n    if len(l) == 2:\n        l.append(\'0\')\n        version = \'.\'.join(l)\n\n    # Build and cache the result\n    result = (name, version, branch, revision, buildno, builddate, compiler)\n    _sys_version_cache[sys_version] = result\n    return result\n\ndef python_implementation():\n\n    """ Returns a string identifying the Python implementation.\n\n        Currently, the following implementations are identified:\n          \'CPython\' (C implementation of Python),\n          \'IronPython\' (.NET implementation of Python),\n          \'Jython\' (Java implementation of Python),\n          \'PyPy\' (Python implementation of Python).\n\n    """\n    return _sys_version()[0]\n\ndef python_version():\n\n    """ Returns the Python version as string \'major.minor.patchlevel\'\n\n        Note that unlike the Python sys.version, the returned value\n        will always include the patchlevel (it defaults to 0).\n\n    """\n    return _sys_version()[1]\n\ndef python_version_tuple():\n\n    """ Returns the Python version as tuple (major, minor, patchlevel)\n        of strings.\n\n        Note that unlike the Python sys.version, the returned value\n        will always include the patchlevel (it defaults to 0).\n\n    """\n    return tuple(_sys_version()[1].split(\'.\'))\n\ndef python_branch():\n\n    """ Returns a string identifying the Python implementation\n        branch.\n\n        For CPython this is the SCM branch from which the\n        Python binary was built.\n\n        If not available, an empty string is returned.\n\n    """\n\n    return _sys_version()[2]\n\ndef python_revision():\n\n    """ Returns a string identifying the Python implementation\n        revision.\n\n        For CPython this is the SCM revision from which the\n        Python binary was built.\n\n        If not available, an empty string is returned.\n\n    """\n    return _sys_version()[3]\n\ndef python_build():\n\n    """ Returns a tuple (buildno, builddate) stating the Python\n        build number and date as strings.\n\n    """\n    return _sys_version()[4:6]\n\ndef python_compiler():\n\n    """ Returns a string identifying the compiler used for compiling\n        Python.\n\n    """\n    return _sys_version()[6]\n\n### The Opus Magnum of platform strings :-)\n\n_platform_cache = {}\n\ndef platform(aliased=0, terse=0):\n\n    """ Returns a single string identifying the underlying platform\n        with as much useful information as possible (but no more :).\n\n        The output is intended to be human readable rather than\n        machine parseable. It may look different on different\n        platforms and this is intended.\n\n        If "aliased" is true, the function will use aliases for\n        various platforms that report system names which differ from\n        their common names, e.g. SunOS will be reported as\n        Solaris. The system_alias() function is used to implement\n        this.\n\n        Setting terse to true causes the function to return only the\n        absolute minimum information needed to identify the platform.\n\n    """\n    result = _platform_cache.get((aliased, terse), None)\n    if result is not None:\n        return result\n\n    # Get uname information and then apply platform specific cosmetics\n    # to it...\n    system, node, release, version, machine, processor = uname()\n    if machine == processor:\n        processor = \'\'\n    if aliased:\n        system, release, version = system_alias(system, release, version)\n\n    if system == \'Darwin\':\n        # macOS (darwin kernel)\n        macos_release = mac_ver()[0]\n        if macos_release:\n            system = \'macOS\'\n            release = macos_release\n\n    if system == \'Windows\':\n        # MS platforms\n        rel, vers, csd, ptype = win32_ver(version)\n        if terse:\n            platform = _platform(system, release)\n        else:\n            platform = _platform(system, release, version, csd)\n\n    elif system in (\'Linux\',):\n        # check for libc vs. glibc\n        libcname, libcversion = libc_ver()\n        platform = _platform(system, release, machine, processor,\n                             \'with\',\n                             libcname+libcversion)\n    elif system == \'Java\':\n        # Java platforms\n        r, v, vminfo, (os_name, os_version, os_arch) = java_ver()\n        if terse or not os_name:\n            platform = _platform(system, release, version)\n        else:\n            platform = _platform(system, release, version,\n                                 \'on\',\n                                 os_name, os_version, os_arch)\n\n    else:\n        # Generic handler\n        if terse:\n            platform = _platform(system, release)\n        else:\n            bits, linkage = architecture(sys.executable)\n            platform = _platform(system, release, machine,\n                                 processor, bits, linkage)\n\n    _platform_cache[(aliased, terse)] = platform\n    return platform\n\n### freedesktop.org os-release standard\n# https://www.freedesktop.org/software/systemd/man/os-release.html\n\n# NAME=value with optional quotes (\' or "). The regular expression is less\n# strict than shell lexer, but that\'s ok.\n_os_release_line = re.compile(\n    "^(?P<name>[a-zA-Z0-9_]+)=(?P<quote>[\\"\\\']?)(?P<value>.*)(?P=quote)$"\n)\n# unescape five special characters mentioned in the standard\n_os_release_unescape = re.compile(r"\\\\([\\\\\\$\\"\\\'`])")\n# /etc takes precedence over /usr/lib\n_os_release_candidates = ("/etc/os-release", "/usr/lib/os-release")\n_os_release_cache = None\n\n\ndef _parse_os_release(lines):\n    # These fields are mandatory fields with well-known defaults\n    # in practice all Linux distributions override NAME, ID, and PRETTY_NAME.\n    info = {\n        "NAME": "Linux",\n        "ID": "linux",\n        "PRETTY_NAME": "Linux",\n    }\n\n    for line in lines:\n        mo = _os_release_line.match(line)\n        if mo is not None:\n            info[mo.group(\'name\')] = _os_release_unescape.sub(\n                r"\\1", mo.group(\'value\')\n            )\n\n    return info\n\n\ndef freedesktop_os_release():\n    """Return operation system identification from freedesktop.org os-release\n    """\n    global _os_release_cache\n\n    if _os_release_cache is None:\n        errno = None\n        for candidate in _os_release_candidates:\n            try:\n                with open(candidate, encoding="utf-8") as f:\n                    _os_release_cache = _parse_os_release(f)\n                break\n            except OSError as e:\n                errno = e.errno\n        else:\n            raise OSError(\n                errno,\n                f"Unable to read files {\', \'.join(_os_release_candidates)}"\n            )\n\n    return _os_release_cache.copy()\n\n\n### Command line interface\n\nif __name__ == \'__main__\':\n    # Default is to print the aliased verbose platform string\n    terse = (\'terse\' in sys.argv or \'--terse\' in sys.argv)\n    aliased = (not \'nonaliased\' in sys.argv and not \'--nonaliased\' in sys.argv)\n    print(platform(aliased, terse))\n    sys.exit(0)\n')
    
    import main
    
    ################################################################
    # TermGeckoV3 by Iranjin
    # 
    # If you have any questions, please contact the anything thread on the following server:
    # https://discord.gg/YhwRT7cf3B
    # 
    # This program can be rewritten and distributed under the following conditions:
    # * Credit "iranjin#4548"
    # * No self-promotion or selling is allowed.
    #################################################################
